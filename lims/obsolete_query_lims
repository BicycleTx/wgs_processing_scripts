#!/usr/bin/perl
use strict;
use warnings;
use Data::Dumper;
use File::Basename;
use Getopt::Long;
use File::Slurp;
use JSON::XS;
use File::Find::Rule;
use 5.010.000;

## -----
## Global variables
## -----
my $DATETIME = localtime;
my $SCRIPT = basename $0;
my $DELIM = "\t";
my $NA_CHAR = "NA";
my $LIMS_JSON = '/data/lims/lims.json';
my $PDF_DIR = '/data/cpct/final_reports';
my @OUT_FIELDS = qw( submission sample_id sample_name arrival_date label analysis_type project_name lab_sop_versions lab_status );
my @LAB_DONE_STATUS = qw( finished failed storage );
my $MIN_TUM_PERC = 30;

my $HELP =<<HELP;

  Description
    Parses LIMS JSON file and prints information about the
    requested samples / submissions to screen.
    
  Usage
    $SCRIPT -submission "HMFreg0000"
    $SCRIPT -submission "HMFreg" -regex_match
    $SCRIPT -sample_id "FR11111111"
    $SCRIPT -sample_name "CPCT01010001T"
    $SCRIPT -sample_name "CPCT01010001" -regex_match
    $SCRIPT -unreported (prints a list of biopsies without report)
    
  Output options
    -regex_match    (match with regex instead of exact match)
    -include_rna    (add rna samples in output)
    -include_plasma (add plasma samples in output)
    -delim <s>      (output delim)
    -lims_input <s> (provide your own lims json file for testing)
    -debug          (prints complete/raw json for selection)
    
  Files/locations that are used
    LIMS input FILE: $LIMS_JSON
    
HELP
print $HELP and exit(0) if scalar @ARGV == 0;

## -----
## Gather input
## -----

my %opt = (); # general options
my %inc = (); # include filters
GetOptions (
  "submission=s@"   => \$inc{ submission },
  "sample_id=s@"    => \$inc{ sample_id },
  "sample_name=s@"  => \$inc{ sample_name },
  "regex_match"     => \$opt{ partial_match },
  "include_rna"     => \$opt{ include_rna },
  "include_plasma"  => \$opt{ include_plasma },
  "delim=s"         => \$DELIM,
  "lims_input=s"    => \$opt{ lims_input },
  "unreported"      => \$opt{ unreported },
  "debug"           => \$opt{ debug },
  "help|h"          => \$opt{ help },
) or die "Error in command line arguments\n";
print $HELP and exit(0) if $opt{ help };
$LIMS_JSON = $opt{ lims_input } if $opt{ lims_input };

## -----
## MAIN
## -----

say "## Script: $SCRIPT";
say "## DateTime: $DATETIME";
say "## LimsJson: $LIMS_JSON";

## prepare
my @out_fields = @OUT_FIELDS;
my $lims = readJson( $LIMS_JSON );

## perform selection or action
if ( $opt{ unreported } ){
    printUnreportedBiopsies( $lims, \%opt );
}
else{
    my $samples = queryLims( $lims, \%inc, \%opt );
    printSampleInfo( $samples, \@out_fields, 'sample_name', $opt{ debug } );
}

## -----
## /MAIN
## -----

sub readJson{
    my ($json_file) = @_;
    my $json_txt = read_file( $json_file );
    my $json_obj = decode_json( $json_txt );
    return( $json_obj );
}

sub printSampleInfo{
    my ($samples, $fields, $sortkey, $debugMode) = @_;
    my $sample_count = scalar @$samples;
    
    @$samples = sort { 
        $a->{$sortkey} cmp $b->{$sortkey}
    } @$samples;
    
    ## in debug mode the complete datastructures are printed as json
    if ( $debugMode ){
        my $json_obj = JSON::XS->new->allow_nonref;
        my $json_txt = $json_obj->pretty->encode( $samples );
        print $json_txt."\n";
    }
    else{
        say "## SampleCount: $sample_count";
        say "#".join( $DELIM, @$fields);
        foreach my $sample ( @$samples ){
            my @out = ();
            push @out, getValueByKey( $sample, $_) foreach @$fields;
            say join $DELIM, @out;
        }
    }
}

sub printUnreportedBiopsies{
    my ($lims, $opt) = @_;
    my @out_samples = ();
    my $samples = $lims->{ 'samples' };
    my $final_status_regex = join( "|", @LAB_DONE_STATUS );
    
    my %pdfs = ();
    my @pdf_paths = glob( $PDF_DIR . '/*.pdf' );
    foreach my $pdf_path ( @pdf_paths ){
        my ($pdf_sample) = split( "_", basename( $pdf_path ) );
        $pdfs{ $pdf_sample } = 1;
    }
    
    foreach my $sample_id ( keys %{$samples} ){
        
        my $sample = $samples->{ $sample_id };
        my $sample_name = getValueByKey( $sample, 'sample_name' );
        my $submission = getValueByKey( $sample, 'submission' );
        
        ## skip if report already exists
        next if exists $pdfs{ $sample_name };
        
        ## skip unless is biopsy
        next unless defined $sample->{'analysis_type'};
        next unless $sample->{'analysis_type'} eq 'Somatic_T';
                
        ## skip if not CPCT/DRUP production biopsy
        next unless defined $sample->{'submission'};
        next unless $submission =~ /^(HMFregCPCT|HMFregDRUP)$/;
        
        ## skip T0 biopsies (these should always have a T as well)
        next if $sample_name =~ /T0$/;
        
        ## skip if sample is too old
        next unless defined $sample->{'arrival_date'};
        next if $sample->{'arrival_date'} =~ /(2015|2016|2017)/;
        
        ## skip if lab not ready yet
        next unless defined $sample->{'lab_status'};
        next unless $sample->{'lab_status'} =~ /$final_status_regex/i;
        
        ## find and add R status
        $sample->{ 'ref_status' } = $NA_CHAR;
        if ( exists $sample->{ 'ref_sample_id' } ){
            my $ref_sample_id = $sample->{ 'ref_sample_id' };
            if ( exists $samples->{ $ref_sample_id } ){
                my $ref_sample = $samples->{ $ref_sample_id };
                my $ref_status = getValueByKey( $ref_sample, 'lab_status' );
                $sample->{ ref_status } = $ref_status;
            }
        }
        
        ## tumor percentage specific filtering
        my $tum_perc = getValueByKey( $sample, 'tumor_perc' );
        if ( $tum_perc !~ /^\d+$/ ){
            ## skip biopsies without integer tumor percentage
            next;
        }
        elsif( $tum_perc < $MIN_TUM_PERC ){
            ## keep any low tumor biopsy (these should always be reported)
        }
        elsif ( $submission eq 'HMFregCPCT' ){
            ## skip further CPCT biopsies without ready ref sample
            next if $sample->{'ref_status'} !~ /$final_status_regex/i;
        }
        
        ## ok: ready to report with SBP info added
        addSbpInfoToSampleBySampleId( $sample, $sample_id );
        push @out_samples, $sample;
    }
    
    my @out_fields = qw( sample_name tumor_perc lab_status ref_status sample_id ref_sample_id arrival_date sbp_info );
    printSampleInfo( \@out_samples, \@out_fields, 'lab_status', $opt{ debug } );
}

sub addSbpInfoToSampleBySampleId{
    my ($sample, $sample_id) = @_;
    
    my $sbp_cmd = "query_sbp_api -type runs -filter \"name=${sample_id}\" -json";
    my $sbp_txt = `$sbp_cmd`;
    my $runs = decode_json( $sbp_txt );
    
    ## init new fields in case no runs found
    $sample->{sbp_info} = $NA_CHAR;
    
    foreach my $run ( @$runs ){
        my $ini = getValueByKey( $run, 'ini' );
        my $entity = getValueByKey( $run, 'entity' );
        my $setname = getValueByKey( $run, 'name' );
        my $status = getValueByKey( $run, 'status' ); 
        next if $ini =~ /rerun/i;
        next if $entity !~ /CPCT_|DRUP_/; 
        $sample->{sbp_info} = "$setname ($status)";
    }
    return($sample);
}

sub queryLims{
    my ($lims, $inc, $opt) = @_;
    my @out = ();    
    my @inc_type = keys %$inc;
    my $samples = $lims->{ 'samples' };
    my $submissions = $lims->{ 'submissions' };
    
    foreach my $sample_id ( keys %{$samples} ){
        my $sample = $samples->{ $sample_id };
        next if ( not $opt{ include_rna } ) and ($sample->{analysis_type} =~ /rna/i);
        next if ( not $opt{ include_plasma } ) and ($sample->{analysis_type} =~ /plasma/i);
        
        foreach my $type ( @inc_type ){
            next unless defined $inc->{ $type };
            next unless defined $sample->{ $type };
            my @searches = @{$inc->{ $type }};
            
            foreach my $search ( @searches ){
                my $sample_val = $sample->{ $type } or die "Sample does not have type ($type):\n".Dumper($sample)."\n";
                
                if ( $sample_val eq $search ){
                    push @out, $sample;
                }
                elsif ( $opt->{ partial_match } and ($sample_val =~ m/$search/ ) ){
                    push @out, $sample;
                }
            }
        }
    }
    
    warn "[WARN] No records left with input\n" if scalar @out == 0;
    return \@out;
}

sub getValueByKey{
    my ($obj, $key) = @_;
    
    if ( not defined $obj->{ $key } ){
        say "[EXIT] Cannot find field \"$key\" in datastructure:";
        print Dumper $obj;
        die "[EXIT] Unable to get field $key\n"
    }

    return( $obj->{ $key } );
}
