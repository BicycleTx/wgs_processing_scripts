#!/usr/bin/perl
use strict;
use warnings;
use utf8;

use Data::Dumper;
use File::Basename;
use Getopt::Long;
use File::Slurp;
use JSON;
use File::Copy;
use Spreadsheet::XLSX;
use DateTime::Format::Excel;
use 5.01000;

use constant EMPTY => q{ };
use constant NACHAR => 'NA';
use constant NOTINUSESTRING => 'COLUMNS_NOT_IN_USE_COLLAPSED';

my $CENTER_FILE = '/data/common/dbs/sbp/center2entity.tsv';
my $CPCTIN_FILE = '/data/lims/labfiles/latest_lims_cpct';
my $RESTIN_FILE = '/data/lims/labfiles/latest_lims_rest';
my $PROCIN_FILE = '/data/lims/labfiles/latest_lims_proc';
my $JSONIN_FILE = '/data/lims/labfiles/lims_2017.json';
my $LIMSOUTFILE = '/data/lims/lims.json';
my $BACKUP_DIR  = '/data/lims/previous';

my $SCRIPT  = `basename $0`; chomp( $SCRIPT );
my $HELP = <<"HELP";

  Description
    Parses LIMS excel files and writes to JSON output.
    One object in the json is one sample (by unique 
    sample id/barcode).
    
  Usage
    $SCRIPT -execute
    
  Input files that are used
       centers: $CENTER_FILE
     cpct lims: $CPCTIN_FILE
     rest lims: $RESTIN_FILE
     proc lims: $PROCIN_FILE
     2017 lims: $JSONIN_FILE

  Output files:
    $LIMSOUTFILE (main json output)

HELP

## get and check input
my %opt = ();
GetOptions (
    "out|o=s" => \$opt{ output },
    "execute" => \$opt{ execute },
    "debug"   => \$opt{ debug },
    "help|h"  => \$opt{ help },
) or die("Error in command line arguments\n");

## ---------- 
## INPUT CHECK
## ----------
print $HELP and exit(0) if $opt{ help };
print $HELP and exit(0) unless $opt{ execute };

foreach ( $BACKUP_DIR ){
    die "[EXIT] Dir does not exist ($_)\n" unless -d;
}
foreach ( $CENTER_FILE, $CPCTIN_FILE, $RESTIN_FILE ){
    die "[EXIT] File does not exist ($_)\n" unless -f;
}
$LIMSOUTFILE = $opt{ output } if $opt{ output };

## start with backup of current lims files
foreach ( $LIMSOUTFILE ){
    copy( $_, "$BACKUP_DIR" ) or die "[EXIT] Backup of \"$_\ to $BACKUP_DIR failed: $!";
}

## columns shipments sheet in rest lims (FOR-001 received samples)
my %SHIP_TRANSLATIONS = (
  "Arrival_date"      => 'arrival_date',
  "Project_name"      => 'project_name',
  "HMF_reg"           => 'submission',
  "Requested_product" => 'request',
  "Product_category"  => 'project_type',
  "Sample_count"      => 'sample_count',
  "Lab_is_finished"   => 'has_lab_finished',
  "TAT_lab"           => 'turn_around_time',
  "Contact_name"      => 'contact_name',
  "Contact_email"     => 'contact_email',
  "Remarks"           => 'remarks',
  "Storage_status"    => 'lab_storage_status',
  "pull down options" => NOTINUSESTRING,
);

## columns samples sheet in rest lims (FOR-001 received samples)
my %REST_TRANSLATIONS = (
  "Sample_ID"         => 'sample_id',
  "Sample_name"       => 'sample_name',
  "DNA_conc"          => 'dna_conc',
  "Yield"             => 'yield',
  "Analysis_type"     => 'analysis_type',
  "Partner_sample"    => 'partner_sample',
  "HMF_reg"           => 'submission',
  "SNP_required"      => 'is_snp_required',
  "SNP_exp"           => 'snp_experiment_id',
  "Requested_product" => 'request',
  "State"             => 'lab_status', # lab status
  "Priority"          => 'priority', 
  "Arival_date"       => 'arrival_date',
  "Remarks"           => 'remarks',
);

my %PROC_TRANSLATIONS = (
  'Sample_ID'         => 'sample_id', # eg FR12345678
  'Sample_name'       => 'sample_name', # eg CPCT1234567R
  'Diluted_library'   => 'library_id', # eg FR12345678 (THIS WAS "barcode_3nm")
  'Sop_tracking_code' => 'lab_sop_versions',
);

## columns CPCT tracking sheet
my %CPCT_TRANSLATIONS = (
  'Hospital'                => NOTINUSESTRING,
  'Sampling_date'           => 'sampling_date',
  'Arrival_HMF'             => 'arrival_date',
  'Sample_barcode'          => 'nonisolated_sample_barcode',
  'Patient_name '           => 'patient',
  'Sample_name'             => 'sample_name',
  '#'                       => NOTINUSESTRING,
  'Source '                 => 'sample_source',
  'Yield'                   => 'yield',
  'Sample_ID_DNA'           => 'sample_id',
  'Sample_ID_RNA_or_plasma' => 'plasma_or_rna_sample_id',
  'Pathologie_exp'          => NOTINUSESTRING,
  'Qiasymphony_exp'         => NOTINUSESTRING,
  'Bioanalyser_exp'         => NOTINUSESTRING,
  'Remarks'                 => NOTINUSESTRING,
  ## next block in sheet
  'Primary tumor type'      => 'primary_tum',
  'Biopsy_material '        => NOTINUSESTRING,
  'tumor_%'                 => 'tumor_perc',
  'DNA_conc'                => NOTINUSESTRING,
  'RNA_conc'                => NOTINUSESTRING,
  'RIN_value'               => NOTINUSESTRING,
  'Coupes_barcode'          => NOTINUSESTRING,
  'Biopsy_Remarks'          => NOTINUSESTRING,
  ## next block in sheet
  'Pathologie'              => NOTINUSESTRING,
  'Qiasymphony'             => NOTINUSESTRING,
  'SNP'                     => NOTINUSESTRING,
  'Patient_count '          => NOTINUSESTRING,
  'Status '                 => 'status',
  'DNA_prep/reason_failed'  => NOTINUSESTRING,
  'RNA_prep'                => NOTINUSESTRING,
  'Biopsy_barc_2'           => NOTINUSESTRING,
  'Biopsy_barc_3'           => NOTINUSESTRING,
  'Biopsy_barc_4'           => NOTINUSESTRING,
  ## next block in sheet
  'maand'                   => NOTINUSESTRING,
  'drup '                   => NOTINUSESTRING,
  'not CPCT/DRUP'           => NOTINUSESTRING,
  'Biobank (UMCU)'          => NOTINUSESTRING,
  'Biobank (NKI)'           => NOTINUSESTRING,
  'MAT'                     => NOTINUSESTRING,
);
    
## ---------- 
## DEBUG
## ----------
if ( $opt{ debug } ){
    say "[DEBUG] Contents of CONSTANT hashes:";
    print Dumper( $_ ) foreach (\%CPCT_TRANSLATIONS, \%REST_TRANSLATIONS, \%SHIP_TRANSLATIONS);
}

## ---------- 
## MAIN
## ----------

say "[INFO] START with script \"$SCRIPT\"";

## init all objects that will hold various info
my $dict_centers; # will be hashref with inffo about cpct/drup centers
my $lims_submiss; # will be hashref with info from shipments sheet
my $lims_inprocs; # will be hashref with info from In Process sheet
my $lims_samples; # will be hashref with final info from all excel files comboined

## load initial 2017 lims data as basis
my $lims_2017 = readJson( $JSONIN_FILE );
$lims_samples = $lims_2017->{ 'samples' };
$lims_submiss = $lims_2017->{ 'submissions' };

## parsing input and add to existing 2017 lims data
$dict_centers = parseDictFile( $CENTER_FILE, 'center2centername' );
$lims_inprocs = parseLimsProc( $PROCIN_FILE, \%PROC_TRANSLATIONS );
$lims_submiss = parseLimsSubm( $RESTIN_FILE, \%SHIP_TRANSLATIONS, $lims_submiss );
$lims_samples = parseLimsRest( $RESTIN_FILE, \%REST_TRANSLATIONS, $lims_submiss, $lims_samples );
$lims_samples = parseLimsCPCT( $CPCTIN_FILE, \%CPCT_TRANSLATIONS, $dict_centers, $lims_samples );

## add extra info per sample from In Process sheet
addLabSopString( $lims_samples, $lims_inprocs );

## output final lims file (json with 2 main keys: samples, submissions)
printLimsToJson( $lims_samples, $lims_submiss, $LIMSOUTFILE );

say "[INFO] DONE with script \"$SCRIPT\"";

## ---------- 
## /MAIN
## ----------



## ---------- 
## SUBs
## ----------
sub readJson{
    my ($json_file) = @_;
    say "[INFO] Parsing json file $json_file";
    my $json_txt = read_file( $json_file );
    my $json_obj = decode_json( $json_txt );
    return( $json_obj );
}

sub printLimsToJson{
    my ($samples, $submissions, $out_file) = @_;
    my $samples_count = scalar keys %$samples;
    my $submissions_count = scalar keys %$submissions;

    my %lims = ( 'samples' => $samples, 'submissions' => $submissions );
    #my $json_obj = JSON->new;
    
    #my $json_txt = $json_obj->pretty->encode( \%lims );
    my $json_txt = JSON->new->utf8->pretty->encode(\%lims);
    
    #my $json_txt = encode_json \%lims;
    #my $json_txt = $json_obj->encode( 'UTF-8', \%lims );
    say "[INFO] Writing output to \"$out_file\" ($submissions_count submissions and $samples_count samples)";
    open my $lims_json_fh, '>', $out_file or die "Unable to open output file ($out_file): $!\n";
        print $lims_json_fh $json_txt;
    close $lims_json_fh;
}

sub addLabSopString{
    my ($samples, $inprocessinfo) = @_;
    my $sop_field_name = 'lab_sop_versions';
    foreach my $id ( keys %$samples ){
        if ( exists $inprocessinfo->{ $id } ){
            ## format: PREP(\d+)V(\d+)-QC(\d+)V(\d+)-SEQ(\d+)V(\d+)
            $samples->{ $id }{ $sop_field_name } = $inprocessinfo->{ $id }{ $sop_field_name };
        }
        else{
            $samples->{ $id }{ $sop_field_name } = NACHAR;
        }
    }
}

sub parseDictFile{
    my ($file, $fileType) = @_;
    say "[INFO] Parsing trans file $file";
    my %store = ();
    
    open my $dict_fh, "<", $file or die "$!: Unable to open file ($file)\n";
    while ( <$dict_fh> ){
        next if /^#/ms;
        chomp;
        if ( $fileType eq 'center2centername' ){
            my ( $id, $descr, $name ) = split /\t/;
            die "[EXIT] id occurs multiple times ($id) in file ($file)\n" if exists $store{ $id };
            $store{ $id } = $name if ( $id ne EMPTY and $name ne EMPTY );
        }
        elsif ( $fileType eq 'submission2entity' ){
            my ( $submission, $entity ) = split /\t/;
            die "[EXIT] submission occurs multiple times ($submission) in file ($file)\n" if exists $store{ $submission };
            $store{ $submission } = $entity if ( $submission ne EMPTY and $entity ne EMPTY );
        }
        else{
            die "[EXIT] Filetype not set or not recognized ($fileType)\n";
        }
    }
    close $dict_fh;
    
    return \%store;
}

sub parseLimsCPCT{
    
    my ($file, $translations, $centers_dict, $lims) = @_;
    my %config = (
        excel => $file,
        trans => $translations,
        sheet => 'CPCT tracking',
        h_val => 'Hospital',
        h_row => 4,
        h_col => 1,
    );
    
    my %store = %{$lims};
    
    ## read the excel sheet in question
    my ($header, $sheet_obj, $max_row, $max_col) = parseExcelSheet( \%config );
    
    foreach my $row ($config{ h_row }+1 .. $max_row) {

        my %row_info = ();
        foreach my $col ( $config{ h_col } .. $max_col ){
            my $header_name = $header->[$col-1];
            my $cell = $sheet_obj->get_cell( $row, $col );
            my $val = NACHAR;
            $val = $cell->unformatted() if defined $cell;
            $val = $translations->{ $val } if defined $translations->{ $val };
            $row_info{ $header_name } = $val;
        }
        
        #print Dumper \%row_info;
        #<>;
        
        ## first we work on the dna sample
        my $sample_name = $row_info{ 'sample_name' };
        my $patient_name = $row_info{ 'patient' };
        
        ## skip NA or empty values
        next if not $sample_name or isValueToSkip( $sample_name );
        next if not $patient_name or isValueToSkip( $patient_name );
        
        ## skip particular case of weird historic sample naming
        next if $sample_name =~ /^(CPCT\d{8}|DRUP\d{8}|PMC\d{6})A/ms;
        
        ## also sample should be either CPCT, DRUP or PMC
        if ( $sample_name =~ /^((CPCT|DRUP)\d{2}(\d{2})\d{4})(T|R){1}/ms ){
            my ($patient, $drup_or_cpct, $centerid, $tum_or_ref) = ($1, $2, $3, $4);
            my $centername = $centers_dict->{ $centerid } or die "[EXIT] Center id found ($centerid) but is not defined in dict\n";
            $row_info{ 'label' } = $drup_or_cpct;
            $row_info{ 'patient' } = $patient;
            $row_info{ 'entity' } = $drup_or_cpct.'_'.$centername;
            $row_info{ 'submission' } = 'HMFreg'.$drup_or_cpct;
            $row_info{ 'analysis_type' } = $tum_or_ref eq 'T' ? 'Somatic_T' : 'Somatic_R';
        }
        elsif ( $sample_name =~ /^(PMC\d{6})(T|R){1}/ms ){
            my ($patient, $tum_or_ref) = ($1, $2);
            $row_info{ 'label' } = 'PMC';
            $row_info{ 'patient' } = $patient;
            $row_info{ 'submission' } = "HMFregPMC";
            $row_info{ 'entity' } = "COHORT_PMC01";
            $row_info{ 'analysis_type' } = $tum_or_ref eq 'T' ? 'Somatic_T' : 'Somatic_R';
        }
        else{
            warn "[WARN] Skipped sample $sample_name from CPCT lims because format is not as expected\n";
            next;
        }
        $row_info{ 'project_name' } = $row_info{ 'submission' };
        
        my $unique = $row_info{ 'sample_id' };
        my $isSkipValue = isValueToSkip( $unique );
        
        ## sample misses sample_id if it was not processed
        ## but want to keep for low tumor percentage check
        if ( $isSkipValue ){
            if ( $sample_name =~ /^(CPCT|DRUP|PMC)/ and $sample_name !~ /T0$/ ){
                ## probably a low tumor percentage -> store under name instead of id
                $unique = $sample_name;
            }
            else{
                ## really is a value to skip
                next;
            }
        }
        
        ## some completeness checks
        die "[EXIT] No submission defined for sample ($sample_name)\n" unless $row_info{ 'submission' };
        die "[EXIT] No analysis type defined for sample ($sample_name)\n" unless $row_info{ 'analysis_type' };
        next unless keyIsUnique( \%store, \%row_info, $unique );
        
        ## fix certain fields 
        fixDateFields( \%row_info );
        
        ## store sample info at first uniqe id
        $store{ $unique } = \%row_info;
        
        ## in case of BIOPT we also store rna sample
        ## in case of BLOOD we also store plasma sample
        ## both are set in same field "plasma_or_rna_sample_id"
        my %row_info_copy = %row_info; # a copy because we will alter the object
        
        if ( defined $row_info{ 'sample_source' } ){
            
            my $source = $row_info{ 'sample_source' };
            my $unique = $row_info{ 'plasma_or_rna_sample_id' };
            next if isValueToSkip( $unique );
            
            $row_info_copy{ 'sample_id' } = $unique;
            next unless keyIsUnique( \%store, \%row_info, $unique );
            
            if ( $source eq 'biopt' or $source eq 'Biopt' ){
                $row_info_copy{ 'analysis_type' } = 'RnaAnalysisTODO';
            }
            elsif( $source eq 'blood' or $source eq 'Blood' ){
                $row_info_copy{ 'analysis_type' } = 'PlasmaAnalysisTODO';
            }
            else{
                die "[EXIT] Unexpected value for source ($source) sould be Biopt of Blood?\n";
            }
            
            ## store sample info at second uniqe id
            $store{ $unique } = \%row_info_copy;
        }

    }
    return \%store;
}

sub keyIsUnique{
    my ($objectStore, $newObject, $key) = @_;
    if ( exists $objectStore->{ $key } ){
        my $obj1_name = $objectStore->{ $key }{ 'sample_name' };
        my $obj2_name = $newObject->{ 'sample_name' };
        warn "[WARN] SKIPPING sample $obj2_name with unique key ($key) because key already exists for sample $obj1_name\n";
        return 0;
    }
    else{
        return 1;
    }
}

sub parseLimsRest{
    
    my ($file, $translations, $shipments, $lims) = @_;
    my %config = (
        excel => $file,
        trans => $translations,
        sheet => 'Samples',
        h_val => 'Sample_ID',
        h_row => 1,
        h_col => 1,
    );
    my ($header, $sheet_obj, $max_row, $max_col) = parseExcelSheet( \%config );
    
    my %store = %{$lims};

    foreach my $row ( $config{ h_row }+1 .. $max_row ) {

        my %row_info = ();
        foreach my $col ( $config{ h_col } .. $max_col ){
            my $header_name = $header->[$col-1];
            my $cell = $sheet_obj->get_cell( $row, $col );
            my $val = NACHAR;
            $val = $cell->unformatted() if defined $cell;
            $val = $translations->{ $val } if defined $translations->{ $val };
            $row_info{ $header_name } = $val;
        }
        
        my $sample_name = $row_info{ 'sample_name' } or die "No sample_name in row_info";
        my $sample_id = $row_info{ 'sample_id' } or die "No sample_id in row_info";
        my $submission = $row_info{ 'submission' } or die "No submission in row_info";
        my $analysis_type = $row_info{ 'analysis_type' } or die "No analysis_type in row_info";
        next if isValueToSkip( $sample_name );
        
        $row_info{ 'label' } = 'RESEARCH';
        $row_info{ 'patient' } = $row_info{ 'sample_name' };
        $row_info{ 'entity' } = $row_info{ 'submission' };
        
        ## check data analysis type and set accordingly
        if ( $analysis_type eq 'SomaticsBFX' ){
            my $partner_id = $row_info{ 'partner_sample' } or die "No partner_sample field in row_info";
            if ( $partner_id ne '' and $partner_id ne NACHAR ){
                ## has partner so is somatic T
                $row_info{ 'analysis_type' } = 'Somatic_T';
            }
            else{
                ## has no partner so is somatic R
                $row_info{ 'analysis_type' } = 'Somatic_R';
            }
        }
        elsif ( $analysis_type eq 'GermlineBFX' ){
            ## Single sample germline
            $row_info{ 'analysis_type' } = 'Germline';
        }
        elsif ( $analysis_type eq 'SNPgenotyping' or $analysis_type eq 'SNP' ){
            ## SNPgenotyping: not a sample so skip
            next;
        }
        elsif ( $analysis_type eq 'NoBFX' or $analysis_type eq '' or $analysis_type eq 'NA' ){
            ## None
            $row_info{ 'analysis_type' } = 'NoAnalysis';
        }
        else {
            die "[EXIT] Sample ($sample_name) has unknown analysis type ($analysis_type)\n";
        }
        
        ## add submission info and parse KG
        if ( exists $shipments->{ $submission } ){
            my $sub = $shipments->{ $submission };
            my $project_name = $sub->{ 'project_name' };
            $row_info{ 'project_name' } = $project_name;
            
            if ( $sub->{ 'project_type' } eq 'KG production' ){
                
                my @dvo_parts = split( /\-/, $project_name );
                my $center = uc( $dvo_parts[0] );
                $row_info{ 'entity' } = 'KG_'.$center;
                $row_info{ 'label' } = 'KG';
            }
        }

        my $unique = $row_info{ 'sample_id' };
        next if isValueToSkip( $unique );

        ## checks before storing
        my $regex = "^[0-9a-zA-Z\-]*\$";
        die "[EXIT] FIX IN LAB LIMS: sample_name contains unacceptable chars ($sample_name)\n" if $sample_name !~ /$regex/;
        die "[EXIT] FIX IN LAB LIMS: sample_id contains unacceptable chars ($sample_id)\n" if $sample_id !~ /$regex/;
        die "[EXIT] FIX IN LAB LIMS: no submission defined for sample ($sample_name)\n" unless $row_info{ 'submission' };
        die "[EXIT] FIX IN LAB LIMS: no analysis type defined for sample ($sample_name)\n" unless $row_info{ 'analysis_type' };
        die "[EXIT] FIX IN LAB LIMS: no project name defined for sample ($sample_name)\n" unless $row_info{ 'project_name' };
        next unless keyIsUnique( \%store, \%row_info, $unique );
        
        
        ## fix certain fields 
        fixDateFields( \%row_info );
        
        ## store sample info at uniqe id
        $store{ $unique } = \%row_info;
        
    }
    return \%store;
}

sub parseLimsProc{
    
    my ($file, $translations) = @_;
    
    my %config = (
        excel => $file,
        trans => $translations,
        sheet => 'Sample in process, Results',
        h_val => 'Sample_ID',
        h_row => 4,
        h_col => 1,
    );
    my ($header, $sheet_obj, $max_row, $max_col) = parseExcelSheet( \%config );
    
    my %store = ();
    
    foreach my $row ( $config{ h_row }+1 .. $max_row ) {

        my %row_info = ();
        foreach my $col ( $config{ h_col } .. $max_col ){
            my $header_name = $header->[$col-1];
            my $cell = $sheet_obj->get_cell( $row, $col );
            my $val = NACHAR;
            $val = $cell->unformatted() if defined $cell;
            $val = $translations->{ $val } if defined $translations->{ $val };
            $row_info{ $header_name } = $val;
        }
        
        my $unique = $row_info{ 'sample_id' };
        next if isValueToSkip( $unique );
        next unless keyIsUnique( \%store, \%row_info, $unique );
        
        ## store shipment info at uniqe id
        $store{ $unique } = \%row_info;
        
    }
    
    return \%store;
}

sub parseLimsSubm{
    
    my ($file, $translations, $lims) = @_;
    
    my %config = (
        excel => $file,
        trans => $translations,
        sheet => 'Shipments',
        h_val => 'Arrival_date',
        h_row => 4,
        h_col => 1,
    );
    my ($header, $sheet_obj, $max_row, $max_col) = parseExcelSheet( \%config );
    
    my %store = %{$lims};
    
    foreach my $row ( $config{ h_row }+1 .. $max_row ) {

        my %row_info = ();
        foreach my $col ( $config{ h_col } .. $max_col ){
            my $header_name = $header->[$col-1];
            my $cell = $sheet_obj->get_cell( $row, $col );
            my $val = NACHAR;
            $val = $cell->unformatted() if defined $cell;
            $val = $translations->{ $val } if defined $translations->{ $val };
            $row_info{ $header_name } = $val;
        }
        
        my $unique = $row_info{ 'submission' };
        next if isValueToSkip( $unique );
        
        ## have to get correct format for certain fields 
        fixDateFields( \%row_info );
        
        ## store shipment info at uniqe id
        $store{ $unique } = \%row_info;
    }
    
    return \%store;
}

sub fixDateFields{
    my ($sample_hashref) = @_;
    
    my @date_fields = qw( arrival_date sampling_date );
    
    foreach my $date_field ( @date_fields ){
        
        next unless exists $sample_hashref->{ $date_field };
        my $new_date = "DATE_WAS_NOT_PARSED";
        my $old_date = $sample_hashref->{ $date_field };
        my $identifier = $sample_hashref->{ 'sample_name' };
        
        ## date is not always filled in so skip NA fields
        next if isValueToSkip( $old_date );
        
        ## Convert all date strings to same format yyyy-mm-dd (eg 2017-01-31)        
        if ( $old_date =~ /^(\d{4})-(\d{2})-(\d{2})$/ ){
            ## case yyyy-mm-dd already ok
            die "[EXIT] Month higher than 12 not possible ($old_date) for sample ($identifier): fix this first\n" if $2 > 12;
            $new_date = $old_date;
        }
        elsif ( $old_date =~ /^(\d{2})-(\d{2})-(\d{4})$/ ){
            ## dd-mm-yyyy
            die "[EXIT] Month higher than 12 not possible ($old_date) for sample ($identifier): fix this first\n" if $2 > 12;
            $new_date = join( "-", $3, $2, $1 );
        }
        elsif ( $old_date =~ /^\d+$/ ){
            ## epoch time
            my $datetime = DateTime::Format::Excel->parse_datetime( $old_date );
            $new_date = $datetime->ymd(); ## eg 2017-01-31
        }
        else{
            warn "[WARN] Date string \"$old_date\" in field \"$date_field\" has unknown format for sample ($identifier): kept string as-is but please fix\n";
            $new_date = $old_date;
        }
        
        ## store new format using reference to original location
        $sample_hashref->{ $date_field } = $new_date;
    }
}

sub parseExcelSheet{
    my ($config) = @_;
    
    my $excel = $config->{ 'excel' };
    my $h_val = $config->{ 'h_val' };
    my $h_col = $config->{ 'h_col' };
    my $h_row = $config->{ 'h_row' };
    my $trans = $config->{ 'trans' };
    my $sheet = $config->{ 'sheet' };
    
    say "[INFO] Loading excel file $excel sheet \"$sheet\"";
    my $workbook = Spreadsheet::XLSX->new( $excel ) or die "[EXIT] Unable to load excel file $excel: $!\n";
    my $sheet_obj = $workbook->worksheet( $sheet ) or die "[EXIT] Unable to read sheet \"$sheet\" from file $excel: $!\n";
    
    my @header = ();
    my $max_row = $sheet_obj->{'MaxRow'};
    my $max_col = $sheet_obj->{'MaxCol'};
    
    ## check if header exist where it should be
    my $first_val = EMPTY;
    my $first_cel = $sheet_obj->get_cell( $h_row, $h_col );
    $first_val = $first_cel->unformatted() if defined $first_cel;
    die "[EXIT] Header value ($h_val) cannot be found at set location ($excel)\n" unless $first_val eq $h_val;
    
    ## now read header values for later storage
    foreach my $col ( $h_col .. $max_col ){
        my $cell = $sheet_obj->get_cell( $h_row, $col );
        my $cell_val = NACHAR;
        $cell_val = $cell->unformatted() if defined $cell;
        $cell_val = $trans->{ $cell_val } if defined $trans->{ $cell_val };
        push( @header, $cell_val );
    }
    
    return( \@header, $sheet_obj, $max_row, $max_col );
}

sub isValueToSkip{
    my ($value) = @_;
    die "[EXIT] Value to check for skipping is not defined\n" if not defined $value;
    my @to_skip = ( NACHAR, EMPTY, 'na', 'naR', 'naT', 'invalid', 'failed', 'nvt', 'no', 'x' );
    foreach my $skip_string ( @to_skip ){
        return 1 if $value =~ /^$skip_string$/i;
    }
    return 0;
}

sub getValueFromHashByKey{
    my ($hashref, $key) = @_;
    my $out = "";
    if ( defined $hashref->{ $key } ){
        $out = $hashref->{ $key };
    }
    return $out;
}

sub debugHash{
    my ($hashref, $msg) = @_;
    my $stdout_msg = "[DEBUG] hash for debug";
    $stdout_msg .= " ($msg)" if defined $msg;
    say $stdout_msg;
    print Dumper $hashref;
    <>;
}
