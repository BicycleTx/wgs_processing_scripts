#!/usr/bin/perl
use strict;
use warnings;
use Data::Dumper;
use File::Basename;
use Getopt::Long;
use File::Slurp;
use JSON::XS;
use File::Find::Rule;
use 5.010.000;

## -----
## Global variables
## -----
my $DATETIME = localtime;
my $SCRIPT = basename $0;
my $LIMS_JSON = '/data/lims/lims.json';
my $PDF_DIR = '/data/cpct/final_reports';

my $DELIM = "\t";
my $NA_CHAR = "NA";
my $MIN_TUM_PERC = 30;
my $TYPE;
my $MUST_MATCH_EXACT;

my @LAB_DONE_STATUS = qw( finished failed storage );
my %OUT_FIELDS_PER_TYPE = (
  'samples'     => [qw( submission sample_id sample_name arrival_date label analysis_type project_name lab_sop_versions lab_status )],
  'submissions' => [qw( submission project_name contact_name contact_email project_type analysis_type sample_count )],
  'unreported'  => [qw( sample_name tumor_perc lab_status ref_status sample_id ref_sample_id arrival_date sbp_info )],
  'dateTable'   => [qw( sample_name sampling_date arrival_date )],
);
my $available_types = join( ", ", sort keys %OUT_FIELDS_PER_TYPE );

my $HELP_TEXT =<<HELP;

  Description
    Parses LIMS JSON file and prints information about the
    requested samples / submissions to screen. Uses regex
    matching of filters by default.
    
  Usage
    $SCRIPT -tyoe samples
    $SCRIPT -tyoe submissions
    $SCRIPT -type samples -filter "submission=HMFreg"
    $SCRIPT -type samples -filter "sample_id=FR11111111"
    $SCRIPT -type samples -filter "sample_name=CPCT01010001T" -exact
    $SCRIPT -type unreported 
      (prints a list of biopsies without pdf report)

  Available types: 
     $available_types
    
  Selection options
    -exact      (match filters with \"eq\" instead of regex)
    -rna        (include rna samples in output)
    -plasma     (include plasma samples in output)
    
  Input/Output options:
    -delim  <s> (output delim)
    -lims   <s> (use alternate input json file)
    -json       (output objects in json format)
    
  Files/locations that are used
    LIMS input FILE: $LIMS_JSON
    Patient reports: $PDF_DIR
HELP

die $HELP_TEXT . "\n" if scalar @ARGV == 0;

## -----
## Gather input
## -----

my %opt = (); # general options
my %inc = (); # include filters
GetOptions (
    "type=s"    => \$TYPE,
    "exact"     => \$MUST_MATCH_EXACT,
    "delim=s"   => \$DELIM,
    "filter=s@" => \$opt{ filters },
    "rna"       => \$opt{ include_rna },
    "plasma"    => \$opt{ include_plasma },
    "lims=s"    => \$opt{ lims_input },
    "json"      => \$opt{ json },
    "debug"     => \$opt{ debug },
    "help|h"    => \$opt{ help },
) or die "Error in command line arguments\n";
die $HELP_TEXT . "\n" if $opt{'help'};
die $HELP_TEXT . "\n[EXIT] Please provide type with -type\n" unless $TYPE;
die $HELP_TEXT . "\n[EXIT] Type ($TYPE) is not supported\n" unless exists $OUT_FIELDS_PER_TYPE{ $TYPE };

## -----
## MAIN
## -----

my $lims = readJson( $opt{ lims_input } or $LIMS_JSON );
my $out_fields = $OUT_FIELDS_PER_TYPE{ $TYPE };

if ( $TYPE eq 'unreported' ){
    my $samples = getUnreportedBiopsies( $lims, \%opt );
    printObjectInfo( $samples, $out_fields, 'lab_status', $opt{ json } );
}
elsif ( $TYPE eq 'dateTable' ){
    my $samples = getCpctDrupDateTable( $lims, \%opt );
    printObjectInfo( $samples, $out_fields, 'sample_name', $opt{ json } );
}
elsif( $TYPE eq 'samples' ){
    my $samples = filterSamples( $lims, \%opt );
    printObjectInfo( $samples, $out_fields, 'sample_name', $opt{ json } );
}
elsif( $TYPE eq 'submissions' ){
    my $submissions = [];
    foreach my $subm_name ( keys %{$lims->{submissions}} ){
        push( @$submissions, $lims->{submissions}->{ $subm_name } );
    }
    printObjectInfo( $submissions, $out_fields, 'submission', $opt{ json } );
}

## -----
## /MAIN
## -----

sub filterSamples{
    my ($lims, $opt) = @_;
    my $filters = $opt{ 'filters' };
    my $samples = $lims->{ 'samples' };
    
    my @selected_objects = ();    
    foreach my $sample_id ( keys %{$samples} ){
        my $sample = $samples->{ $sample_id };
        next if ( not $opt{ include_rna } ) and ($sample->{analysis_type} =~ /rna/i);
        next if ( not $opt{ include_plasma } ) and ($sample->{analysis_type} =~ /plasma/i);
        push @selected_objects, $sample;
    }
    
    my $filtered_objects = filterObjects( \@selected_objects, $filters );
    
    return $filtered_objects;
}

sub filterObjects{
    my ($objects, $filters) = @_;
    
    my @out = ();
    my %filter_counts = ();
    
    foreach my $obj ( @$objects ){
        my $do_skip_object = applyFiltersOnObject( $obj, $filters, \%filter_counts );
        push( @out, $obj ) unless $do_skip_object;        
    }
    
    
    foreach my $filter ( keys %filter_counts ){
        my $count = $filter_counts{ $filter };
        say "## Filter: $count filtered away by filter \"$filter\"";
    }
    
    return \@out;
}

sub applyFiltersOnObject{
    my ($object, $filters, $counts) = @_;
        
    foreach my $filter_string ( @$filters ){
        
        my ($name, $include) = split( "=", $filter_string );
                    
        if ( not exists $object->{ $name } ){
            $counts->{ $name.'=KeyNotExists' }++;
            return(1);
        }
        elsif ( not defined $object->{ $name } ){
            $counts->{ $name.'=KeyNotDefined' }++;
            return(1);
        }
        else{
            my $to_match = $object->{ $name };
            my $exact_match = $object->{ $name } eq $include;
            my $regex_match = $object->{ $name } =~ m/$include/i;
            
            if ( not $exact_match and $MUST_MATCH_EXACT ){
                $counts->{ $filter_string }++;
                return(1);
            }
            elsif( not $regex_match ){
                $counts->{ $filter_string }++;
                return(1);
            }
        }
    }
    
    ## all filters applied and still here so return OK response
    return 0;
}

sub readJson{
    my ($json_file) = @_;
    my $json_txt = read_file( $json_file );
    my $json_obj = decode_json( $json_txt );
    return( $json_obj );
}

sub printObjectInfo{
    my ($objects, $fields, $sortkey, $outputAsJson) = @_;
    my $count = scalar @$objects;
    
    unless ( $outputAsJson ){
        say "## Script: $SCRIPT";
        say "## DateTime: $DATETIME";
        say "## InputJson: $LIMS_JSON";
    }
    
    @$objects = sort { 
        $a->{$sortkey} cmp $b->{$sortkey}
    } @$objects;
    
    if ( $outputAsJson ){
        my $json_obj = JSON::XS->new->allow_nonref;
        my $json_txt = $json_obj->pretty->encode( $objects );
        print $json_txt;
    }
    else{
        say "## ObjectCount: $count";
        say "#".join( $DELIM, @$fields);
        foreach my $obj ( @$objects ){
            my @out = ();
            push @out, getValueByKey( $obj, $_) foreach @$fields;
            say join $DELIM, @out;
        }
    }
}

sub getCpctDrupDateTable{
    my ($lims) = @_;
    my @out_samples = ();
    my $samples = $lims->{ 'samples' };
    
    foreach my $sample_id ( keys %{$samples} ){

        my $sample = $samples->{ $sample_id };
        my $sample_name = getValueByKey( $sample, 'sample_name' );
        my $submission = getValueByKey( $sample, 'submission' );
        
        ## skip if not CPCT/DRUP production biopsy
        next unless defined $sample->{'analysis_type'};
        next unless $sample->{'analysis_type'} =~ /^(Somatic_T|Somatic_R)$/;
        next unless defined $sample->{'submission'};
        next unless $submission =~ /^(HMFregCPCT|HMFregDRUP)$/;
        
        push @out_samples, $sample;
    }
    return( \@out_samples );
}


sub getUnreportedBiopsies{
    my ($lims) = @_;
    my @out_samples = ();
    my $samples = $lims->{ 'samples' };
    my $final_status_regex = join( "|", @LAB_DONE_STATUS );
    
    my %pdfs = ();
    my @pdf_paths = glob( $PDF_DIR . '/*.pdf' );
    foreach my $pdf_path ( @pdf_paths ){
        my ($pdf_sample) = split( "_", basename( $pdf_path ) );
        $pdfs{ $pdf_sample } = 1;
    }
    
    foreach my $sample_id ( keys %{$samples} ){
        
        my $sample = $samples->{ $sample_id };
        my $sample_name = getValueByKey( $sample, 'sample_name' );
        my $submission = getValueByKey( $sample, 'submission' );
        
        ## skip if report already exists
        next if exists $pdfs{ $sample_name };
        
        ## skip unless is biopsy
        next unless defined $sample->{'analysis_type'};
        next unless $sample->{'analysis_type'} eq 'Somatic_T';
                
        ## skip if not CPCT/DRUP production biopsy
        next unless defined $sample->{'submission'};
        next unless $submission =~ /^(HMFregCPCT|HMFregDRUP)$/;
        
        ## skip T0 biopsies (these should always have a T as well)
        next if $sample_name =~ /T0$/;
        
        ## skip if sample is too old
        next unless defined $sample->{'arrival_date'};
        next if $sample->{'arrival_date'} =~ /(2015|2016|2017)/;
        
        ## skip if lab not ready yet
        next unless defined $sample->{'lab_status'};
        next unless $sample->{'lab_status'} =~ /$final_status_regex/i;
        
        ## find and add R status
        $sample->{ 'ref_status' } = $NA_CHAR;
        if ( exists $sample->{ 'ref_sample_id' } ){
            my $ref_sample_id = $sample->{ 'ref_sample_id' };
            if ( exists $samples->{ $ref_sample_id } ){
                my $ref_sample = $samples->{ $ref_sample_id };
                my $ref_status = getValueByKey( $ref_sample, 'lab_status' );
                $sample->{ ref_status } = $ref_status;
            }
        }
        
        ## tumor percentage specific filtering
        my $tum_perc = getValueByKey( $sample, 'tumor_perc' );
        if ( $tum_perc !~ /^\d+$/ ){
            ## skip biopsies without integer tumor percentage
            next;
        }
        elsif( $tum_perc < $MIN_TUM_PERC ){
            ## keep any low tumor biopsy (these should always be reported)
        }
        elsif ( $submission eq 'HMFregCPCT' ){
            ## skip further CPCT biopsies without ready ref sample
            next if $sample->{'ref_status'} !~ /$final_status_regex/i;
        }
        
        ## ok: ready to report with SBP info added
        addSbpInfoToSampleBySampleId( $sample, $sample_id );
        push @out_samples, $sample;
    }
    
    return( \@out_samples );
}

sub addSbpInfoToSampleBySampleId{
    my ($sample, $sample_id) = @_;
    
    my $sbp_cmd = "query_sbp_api -type runs -filter \"name=${sample_id}\" -json";
    my $sbp_txt = `$sbp_cmd`;
    my $runs = decode_json( $sbp_txt );
    
    ## init new fields in case no runs found
    $sample->{sbp_info} = $NA_CHAR;
    
    foreach my $run ( @$runs ){
        my $ini = getValueByKey( $run, 'ini' );
        my $entity = getValueByKey( $run, 'entity' );
        my $setname = getValueByKey( $run, 'name' );
        my $status = getValueByKey( $run, 'status' ); 
        next if $ini =~ /rerun/i;
        next if $entity !~ /CPCT_|DRUP_/; 
        $sample->{sbp_info} = "$setname ($status)";
    }
    return($sample);
}

sub getValueByKey{
    my ($obj, $key) = @_;
    if ( not defined $obj->{ $key } ){
        return( $NA_CHAR );
    }
    return( $obj->{ $key } );
}
