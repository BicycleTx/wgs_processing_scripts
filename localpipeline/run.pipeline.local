#!/bin/bash
# KODU local pipeline for running tumor/normal algo's.

# Control parameters
RESET_OUTPUT_DIR_BEFORE_RUN=true
RUN_ALGOS_PER_SAMPLE=true
RUN_STRELKA=true
RUN_VARSCAN=true
RUN_FREEBAYES=true
RUN_MUTECT=true

RUN_SOMATIC_POSTPROCESS=true

SAMPLE_ID=chr17testdata   #'cancerPanel' or 'chr17testdata'

dbspath=~/hmf/data/dbs
out=~/hmf/out
qc=${out}/qc
tmp=${out}/tmp

if [ ${SAMPLE_ID} == cancerPanel ]; then
	fastqpath=~/hmf/repos/testdata/cancerPanel
	ref=~/hmf/data/refgenomes/Homo_sapiens.GRCh37.GATK.illumina/Homo_sapiens.GRCh37.GATK.illumina.fasta
	
	bloodsample=CPCT12345678R
	bloodflowcell=HJJLGCCXX
	bloodindex=S1

	tumorsample=${bloodsample} #CPCT12345678T
	tumorflowcell=HJJLGCCXX
	tumorindex=S1
elif [ ${SAMPLE_ID} == chr17testdata ]; then
	fastqpath=~/hmf/repos/testdata/12878-chr17-fq/12878-chr17-200k
	ref=~/hmf/data/refgenomes/chr17/chr17.fasta
	
	bloodsample=12878
	bloodflowcell=chr17
	bloodindex=200k  #'200k' '1M' or 'ALL'
	
	tumorsample=${bloodsample}
	tumorflowcell=${bloodflowCell}
	tumorindex=${bloodindex}
else
	exit "Error: Invalid Sample Id"
fi


# Actual pipeline starts now!
if [ ${RESET_OUTPUT_DIR_BEFORE_RUN} == true ]; then
	rm -r ${out}/*
	mkdir ${qc}
	mkdir ${tmp}	
fi

if [ ${RUN_ALGOS_PER_SAMPLE} == true ]; then
    # KODU: This generates a bam file ${out}/${bloodsample}.bam
	run.algos.per.sample ${fastqpath} ${dbspath} ${ref} ${out} ${qc} ${bloodsample} ${bloodflowcell} ${bloodindex}
	# KODU: This generates a bam file ${out}/${tumorsample}.bam
	# run.algos.per.sample ${fastqpath} ${dbspath} ${ref} ${out} ${qc} ${tumorsample} ${tumorflowcell} ${tumorindex}
fi 

bloodbam=${out}/${bloodsample}.bam
tumorbam=${out}/${tumorsample}.bam

if [ ${RUN_STRELKA} == true ]; then
    echo -e "\nRunning Strelka\n"
    strelkapath=${out}/strelka

    rm -r ${strelkapath}
    if [ -d "${strelkapath}" ]; then
        rm -r ${strelkapath}
    fi
    
    prefix=`dirname $(readlink $0 || echo $0)`
    strelkaconfig=${prefix}/strelka.ini
    strelka --tumor ${tumorbam} --normal ${bloodbam} --ref ${ref} --config ${strelkaconfig} --output-dir ${strelkapath};
    make -C ${strelkapath}

    gatk -T CombineVariants -R ${ref} --genotypemergeoption unsorted -o ${out}/strelka.passed.somatic.merged.vcf -V ${strelkapath}/results/passed.somatic.snvs.vcf -V ${strelkapath}/results/passed.somatic.indels.vcf
    perl -p -e 's/\t([A-Z][A-Z]:)/\tGT:$1/g' ${out}/strelka.passed.somatic.merged.vcf | perl -p -e 's/(:T[UO]R?)\t/$1\t0\/0:/g' | perl -p -e 's/(:\d+,\d+)\t/$1\t0\/1:/g' | perl -p -e 's/(#CHROM.*)/##StrelkaGATKCompatibility=Added GT fields to strelka calls for gatk compatibility.\n$1/g' > ${tmp}/temp.vcf
    mv ${tmp}/temp.vcf ${out}/strelka.passed.somatic.merged.final.vcf
fi

strelka=${out}/strelka.passed.somatic.merged.final.vcf

if [ ${RUN_VARSCAN} == true ]; then
	echo -e "\nRunning pileup to prepare input for varscan\n"
	bloodpileup=${out}/${bloodsample}.pileup
	# KODU: In production we pipe the pileup to tabix/bgzip and then uncompress it when feeding to varscan.
	# We don't do that here since we don't run varscan per chromosome  and the pileup file isn't large for test data
	sambamba mpileup --tmpdir=${tmp} ${bloodbam} --samtools "-q 1 -f ${ref}" > ${bloodpileup}
    tabix -s 1 -b 2 -e 2 ${bloodpileup}

    tumorpileup=${out}/${tumorsample}.pileup
    # KODU: In production we pipe the pileup to tabix/bgzip and then uncompress it when feeding to varscan.
    # We don't do that here since we don't run varscan per chromosome  and the pileup file isn't large for test data
    sambamba mpileup --tmpdir=${tmp} ${tumorbam} --samtools "-q 1 -f ${ref}" > ${tumorpileup}
    tabix -s 1 -b 2 -e 2 ${tumorpileup}

	echo -e "\nRunning varscan\n"
	varscanoutput=${out}/varscan
	varscan somatic ${bloodpileup} ${tumorpileup} ${varscanoutput} --min-coverage 20 --min-var-freq 0.1 --tumor-purity 0.8 --output-vcf 1
	varscan processSomatic ${varscanoutput}.snp.vcf -max-normal-freq 0.02 --p-value 0.05
	varscan processSomatic ${varscanoutput}.indel.vcf -max-normal-freq 0.02 --p-value 0.05

    gatk -T CombineVariants -R ${ref} --genotypemergeoption unsorted -o ${varscanoutput}.merged.Somatic.hc.vcf -V ${varscanoutput}.snp.Somatic.hc.vcf -V ${varscanoutput}.indel.Somatic.hc.vcf
    # KODU: For mac OS, the backup extension (".bak") is mandatory when calling sed
    # This find-and-replace is supposedly done to differentiate varscan from freebayes eventually.
    sed -i .bak 's/SSC/VS_SSC/' ${varscanoutput}.merged.Somatic.hc.vcf
fi

varscan=${out}/varscan.merged.Somatic.hc.vcf

if [ ${RUN_FREEBAYES} == true ]; then
    echo -e "\nRunning freebayes\n"
    freebayes -f ${ref} -C 3 --pooled-discrete --genotype-qualities --min-coverage 5 --no-mnps --no-complex ${bloodbam} ${tumorbam} > ${out}/freebayes.raw.vcf

    # KODU: Below command is run per CHR in production
    vcftools vcf-sort -c -t ${tmp} ${out}/freebayes.raw.vcf | vcflib vcfuniq > ${out}/freebayes.sorted_uniq.vcf

    # KODU: This command is run on the merged vcfs in production.
    uniq ${out}/freebayes.sorted_uniq.vcf > ${out}/freebayes.vcf

    sampleR=`grep -P "^#CHROM" ${out}/freebayes.vcf | cut -f 10`
	sampleT=`grep -P "^#CHROM" ${out}/freebayes.vcf | cut -f 11`

    # KODU: This line is there to compensate for the fact we run blood vs blood
    sampleT=${sampleR}

	vcflib vcfsamplediff VT ${sampleR} ${sampleT} ${out}/freebayes.vcf > ${out}/freebayes.VTannot.vcf
	sed -i .bak 's/SSC/FB_SSC/' ${out}/freebayes.VTannot.vcf
	grep -P "^#" ${out}/freebayes.VTannot.vcf > ${out}/freebayes.germline.vcf
	grep -P "^#" ${out}/freebayes.VTannot.vcf > ${out}/freebayes.somatic.vcf
	grep -i "VT=germline" ${out}/freebayes.VTannot.vcf >> ${out}/freebayes.germline.vcf
	grep -i "VT=somatic" ${out}/freebayes.VTannot.vcf >> ${out}/freebayes.somatic.vcf

	cat ${out}/freebayes.somatic.vcf | snpsift filter "(GEN[ALL].DP>=20) & (GEN[ALL].GQ>=15) & (QUAL>=10) & (FB_SSC>=20)" > ${out}/freebayes.filtered.somatic.vcf
	cat ${out}/freebayes.germline.vcf | snpsift filter "(GEN[ALL].DP>=20) & (GEN[ALL].GQ>=15) & (QUAL>=10)" > ${out}/freebayes.filtered.germline.vcf
fi

freebayes=${out}/freebayes.filtered.somatic.vcf

if [ ${RUN_MUTECT} == true ]; then
    echo -e "\nRunning MuTect\n"
    cosmic=${dbspath}/cosmic_v76/CosmicCodingMuts_v76.vcf.gz
    dbsnp=${dbspath}/GATK_bundle_v2.8/dbsnp_137.b37.vcf

    # KODU: Temp code to fool mutect into thinking it gets 2 different samples.
    cp ${out}/${bloodsample}.bam ${out}/${bloodsample}2.bam
    cp ${out}/${bloodsample}.bai ${out}/${bloodsample}2.bai
    bloodbam2=${out}/${bloodsample}2.bam

    export JAVA_HOME=$(/usr/libexec/java_home -v 1.7)
    mutect -T MuTect -R ${ref} --cosmic ${cosmic} --dbsnp ${dbsnp} --input_file:normal ${bloodbam} --input_file:tumor ${bloodbam2} --out ${out}/mutect.out --vcf ${out}/mutect.vcf
    export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)
    cat ${out}/mutect.vcf | snpsift filter "(FILTER = 'PASS')" > ${out}/mutect_passed.vcf
fi

mutect=${out}/mutect_passed.vcf

if [ ${RUN_SOMATIC_POSTPROCESS} == true ]; then
    echo -e "\nRunning somatic postprocessing (merge & annotate)\n"
    
    #Temporarily removing freebayes
    #gatk -T CombineVariants -R ${ref} -o ${out}/merged_somatics.vcf --genotypemergeoption uniquify -V:strelka ${strelka} -V:varscan ${varscan} -V:freebayes ${freebayes} -V:mutect ${mutect}
    gatk -T CombineVariants -R ${ref} -o ${out}/merged_somatics.vcf --genotypemergeoption uniquify -V:strelka ${strelka} -V:varscan ${varscan} -V:mutect ${mutect}

    cosmic=${dbspath}/cosmic_v76/CosmicCodingMuts_v76.vcf.gz
    dbsnp=${dbspath}/GATK_bundle_v2.8/dbsnp_137.b37.vcf

    snpeff GRCh37.74 -s ${out}/somatics_snpEff_summary.html  -v ${out}/merged_somatics.vcf -hgvs -lof -no-downstream -no-upstream -no-intergenic > ${out}/merged_somatics_snpEff.vcf
    gatk -T VariantAnnotator -R ${ref} -o ${out}/merged_somatics_snpEff_dbSNP.vcf --variant ${out}/merged_somatics_snpEff.vcf --dbsnp ${dbsnp} --alwaysAppendDbsnpId
    gatk -T VariantAnnotator -R ${ref} -o ${out}/merged_somatics_snpEff_dbSNP_Cosmicv76.vcf --variant ${out}/merged_somatics_snpEff_dbSNP.vcf --dbsnp ${cosmic} --alwaysAppendDbsnpId

    python melt_somatic_vcf.py -t ${tumorsample} -v ${out}/merged_somatics_snpEff_dbSNP_Cosmicv76.vcf > ${out}/merged_somatics_snpEff_dbSNP_Cosmicv76_melt.vcf
fi

