#!/usr/bin/env bash

source message_functions || exit 1

print_usage(){
    echo "-----"
    echo "Descr: Patches one field in one object of HMF API"
    echo "Usage: $(basename "$0") -c \${object-class} -o \${object-id} -f \${field-to-patch} -v \${value-to-patch-with}"
    echo "Exmpl: $(basename "$0") -c flowcells -o 1000 -f status -v Pending"
    echo "       $(basename "$0") -c fastq -o 1000 -f qc_pass -v false"
    echo "       $(basename "$0") -c fastq -o 1000 -f bucket -v null"
    echo "       $(basename "$0") -c samples -o 1000 -f primary_tumor_doids -v 1,4,92"
    echo "Options:"
    echo "  -e   Do not require to press a key for confirmation"
    echo "  -a   Use acceptence environment instead of production"
    echo "-----"
    exit 1
}

class='' # sets, runs, samples, fastq
oid='' # object id
field='' # the field to PATCH
value='' # the value to PATCH field with
confirmation='true' # by default script requires key press
environment='prod' # by default script requires key press

unquoted_values='null|true|false'
quoted_fields='name|barcode|status|submission|bucket|ref_sample|tumor_sample'
unquoted_fields='yld|yld_req|q30|q30_req|qc_pass'
quoted_array_fields='primary_tumor_doids'
unquoted_array_fields='no_literal_array_fields_yet'
api_dir="/data/common/dbs/api_credentials"

while getopts ':c:o:f:v:ea' flag; do
    case "${flag}" in
        c) class=${OPTARG} ;;
        o) oid=${OPTARG} ;;
        f) field=${OPTARG} ;;
        v) value=${OPTARG} ;;
        e) confirmation='false' ;;
        a) environment='acc' ;;
        *) print_usage >&2
        exit 1 ;;
    esac
done

if [[ -z "${class}" || -z "${oid}" || -z "${field}" || -z "${value}" ]]; then
    print_usage
fi

if [[ "${environment}" == "prod" ]]; then
    api_crt="${api_dir}/api.crt"
    api_key="${api_dir}/api.key"
    api_url="https://api.hartwigmedicalfoundation.nl/hmf/v1"
elif [[ "${environment}" == "acc" ]]; then
    api_crt="${api_dir}/acc/api.crt"
    api_key="${api_dir}/acc/api.key"
    api_url="https://api.acc.hartwigmedicalfoundation.nl/hmf/v1"
else
    die "Environment should be either prod or acc"
fi

main () {
    info "Checking api for object (class=${class}|id=${oid}|env=${environment})"
    object_location="${class}/${oid}"

    # TODO: use hmf_api_get once acceptance environment supported
    json=$(get_with_curl "${object_location}") || die "API GET failed for ${object_location}. Exit."
    name=$(get_name_from_object "${class}" "${json}") || die "Unable to get name from object json. Exit."
    data=$(construct_data_json "${field}" "${value}") || die "Unable to construct the patch json. Exit."

    info_string="name=${name}|class=${class}|id=${oid}|env=${environment}"
    info "About to patch object (${info_string}) with '${data}'"
    if [[ "${confirmation}" == "true" ]]; then
        current_value=$(jq --arg key "${field}" '.[$key]' <<< "${json}")
        info "Will replace ${current_value} with ${value}"
        info "Press [ENTER] to apply..."
        read -r -s
        patch_with_curl "${object_location}" "${data}" || die "API PATCH failed"
    elif [[ "${confirmation}" == "false" ]]; then
        patch_with_curl "${object_location}" "${data}" || die "API PATCH failed"
    else
        die "Unexpected: param confirmation should always be either true or false"
    fi

    # Handle special cases
    if [[ "${class}" == "flowcells" && "${field}" == "undet_rds_p_pass" ]]; then
        info "Recalculating sample yields for flowcell (${info_string})"
        post_with_curl_without_data "flowcells/${oid}/recalculate"
    fi
}

construct_data_json () {
    local field=$1 && shift
    local value=$1 && shift
    local data=""
    if [[ "${value}" =~ ^(${unquoted_values})$ ]]; then
        # assuming null/true/false as value are never meant as string
        data=$(printf '{"%s": %s}' "$field" "${value}")
    elif [[ "${field}" =~ ^(${unquoted_fields})$ ]]; then
        data=$(printf '{"%s": %s}' "$field" "${value}")
    elif [[ "${field}" =~ ^(${quoted_fields})$ ]]; then
        data=$(printf '{"%s": "%s"}' "$field" "${value}")
    elif [[ "${field}" =~ ^(${unquoted_array_fields})$ ]]; then
        data=$(printf '{"%s": [%s]}' "$field" "${value}")
    elif [[ "${field}" =~ ^(${quoted_array_fields})$ ]]; then
        data=$(printf '{"%s": ["%s"]}' "$field" "${value//,/\",\"}")
    else
        die "Field ${field} is not supported"
    fi
    echo "${data}"
}

get_name_from_object () {
    local class=$1 && shift
    local json=$1 && shift
    if [[ "${class}" == "fastq" ]]; then
        jq -r '.name_r1' <<< "${json}"
    elif [[ "${class}" == "runs" ]]; then
        jq -r '.set.name' <<< "${json}"
    else
        jq -r '.name' <<< "${json}"
    fi
}

get_with_curl () {
    local object_location=$1 && shift
    curl -f --silent --show-error -H "Content-Type: application/json" \
    --cert-type pem --cert "${api_crt}" --key "${api_key}" -X GET "${api_url}/${object_location}"
}

patch_with_curl () {
    local object_location=$1 && shift
    local data=$1 && shift
    curl --silent --show-error -H "Content-Type: application/json" -H "Accept: application/json" \
     --cert-type pem --cert "${api_crt}" --key "${api_key}" -X PATCH "${api_url}/${object_location}" --data "${data}" > /dev/null
}

post_with_curl_without_data () {
    local object_location=$1 && shift
    curl --silent --show-error \
     --cert-type pem --cert "${api_crt}" --key "${api_key}" -X POST "${api_url}/${object_location}" > /dev/null
}

main