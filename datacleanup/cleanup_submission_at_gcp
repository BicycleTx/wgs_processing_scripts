#!/usr/bin/env bash

source message_functions || exit 1

OUT_ROOT="/data/ops/cleanup"
GSUTIL_CMD_PARAMS="-m -o GSUtil:parallel_process_count=7 -o GSUtil:parallel_thread_count=1"

# Need to match ini by ID in run object
SIN_INI_ID=4
SOM_INI_ID=6
SHA_INI_ID=38
FAS_INI_ID=10

gcp_project="hmf-database"
gcp_account="hmf-ops"

print_usage(){
    echo "-----"
    echo " Descr: Searches for data in GCP buckets and print code to cleanup"
    echo " Usage: $(basename $0) -s \$submission"
    echo " Examp: $(basename $0) -s HMFregXXXX"
    echo "  Note: Writes output to ${OUT_ROOT}"
    echo "-----"
    exit 1
}

while getopts ':s:' flag; do
    case "${flag}" in
        s) submission=${OPTARG} ;;
        *) print_usage
        exit 1 ;;
    esac
done

if [[ -z "${submission}" ]]; then
    print_usage
fi

main() {
    info "######"
    info "Starting with script $(basename $0) for submission $submission"

    gcp_account_project="${gcp_account}@${gcp_project}"
    info "Setting GCP account ${gcp_account_project}"
    msg=$(gcloud config set account "${gcp_account_project}.iam.gserviceaccount.com" 2>&1)
    info "  ${msg}"

    yymmdd=$(date "+%y%m%d")
    out_path="${OUT_ROOT}/${submission}"
    cmd_file="${out_path}/${yymmdd}_cleanup_${submission}_at_gcp"
    log_file="${out_path}/${yymmdd}_cleanup_${submission}_at_gcp.log"

    ## keeping track
    run_count=0

    ## some input sanity checks
    info "Performing some sanity checks"
    [[ ! -w "${OUT_ROOT}" ]] || die "Out root not writable (${OUT_ROOT})"
    [[ ! -f "${cmd_file}" ]] || die "CMD file already exists (${cmd_file})"
    [[ ! -f "${log_file}" ]] || die "LOG file already exists (${log_file})"

    # setup output dir
    mkdir -p "${out_path}"

    # all while loops use process substitution to avoid subprocesses
    info "Retrieving runs involved (via samples->sets)"
    samples_json=$(hmf_api_get "samples?submission=${submission}") 

    # add start message to cmd file
    echo "echo '[INFO] Starting cleanup for submission ${submission}'" >> "${cmd_file}"

    while read sample; do
        sample_id=$(echo "$sample" | jq -r '.id')
        sample_barcode=$(echo "$sample" | jq -r '.barcode')
        sample_status=$(echo "$sample" | jq -r '.status')
        sets_json=$(hmf_api_get "sets?sample_id=${sample_id}")

        while read set; do
            set_id=$(echo "$set" | jq -r '.id')
            runs_json=$(hmf_api_get "runs?set_id=${set_id}")

            while read run; do
                run_id=$(echo "$run" | jq -r '.id')
                run_name=$(echo "$run" | jq -r '.set.name')
                bucket=$(echo "$run" | jq -r '.bucket')

                # Pre-GCP buckets might still have underscores that need to be replaced
                bucket=${bucket/_/-}

                run_status=$(echo "$run" | jq -r '.status')
                ini_id=$(echo "$run" | jq -r '.ini_id')
                gs_url="gs://${bucket}/${run_name}"
                run_type=$(run_type_by_ini_id "${ini_id}")

                run_info="run $run_id ($run_status) of type $run_type for set $set_id by sample $sample_id ($sample_status)"
                info "Processing run ${run_info}"
                echo "echo '[INFO] Performing steps for run ${run_info}'" >> "${cmd_file}"

                if [[ "${run_type}" == "fastq" ]]; then
                    echo "  hmf_api_patch -c 'samples' -o '${sample_id}' -f 'status' -v 'Deleted' -e" >> "${cmd_file}"
                    files_api_url="files?run_id=${run_id}"
                    files_json=$(hmf_api_get "${files_api_url}")
                    mapfile -t all_gs_urls < <( echo ${files_json} | jq -r '.[].filepath' )
                    for fastq_file_url in "${all_gs_urls[@]}"; do
                        process_gs_url "${sample_status}" "${fastq_file_url}" "${cmd_file}"
                    done
                elif [[ "${run_type}" == "pipeline" ]]; then
                    process_gs_url "${run_status}" "${gs_url}" "${cmd_file}"
                else
                    die "Run somehow not FASTQ and NOT pipeline (type=${run_type}, ini=${ini_id}): this should not happen!"
                fi
                echo "  hmf_api_patch -c 'runs' -o '${run_id}' -f 'status' -v 'Deleted' -e" >> "${cmd_file}"
                ((run_count++))
            done < <(echo "$runs_json" | jq -c '.[]')
        done < <(echo "$sets_json" | jq -c '.[]')
    done < <(echo "$samples_json" | jq -c '.[]')
    
    # Finish up cmd file by last echo msg
    echo "echo '[INFO] Finished cleanup for submission ${submission}'" >> "${cmd_file}"

    info "A total of ${run_count} runs visited"
    info "Making output cmd file executable (${cmd_file})"
    chmod +x "${cmd_file}"
    info "If all ok you can execute deletion with:"
    info "  nohup ${cmd_file} > ${log_file} &"
    info "Finished with $(basename $0)"
}

run_type_by_ini_id() {
    local ini_id=$1 && shift

    local pipeline="pipeline"
    local fastq="fastq"
    local unknown="unknown"

    if [[ "$ini_id" == "$FAS_INI_ID" ]]; then
        echo "$fastq"
    elif [[ "$ini_id" == "$SOM_INI_ID" ]]; then
        echo "$pipeline"
    elif [[ "$ini_id" == "$SIN_INI_ID" ]]; then
        echo "$pipeline"
    elif [[ "$ini_id" == "$SHA_INI_ID" ]]; then
        echo "$pipeline"
    else
        echo "$unknown"
    fi

}

process_gs_url() {
    local status=$1 && shift
    local gs_url=$1 && shift
    local out_file=$1 && shift
    
    msg=$(gsutil -u "${gcp_project}" ls "${gs_url}" 2>&1)
    if [[ $? -eq 1 ]]; then
        if [[ "${status}" == "Deleted" ]]; then
            info "  SKIPPING: url not found but object status is ${status} so makes sense (${gs_url})"
        else
            warn "  SKIPPING: url not found but object status (${status}) is not Deleted (${gs_url})"
        fi
    else
        info "  Writing rm command for valid URL ($gs_url)"
        echo "  gsutil -u '${gcp_project}' ${GSUTIL_CMD_PARAMS} rm -r '${gs_url}'" >> "${out_file}"
    fi
}

main