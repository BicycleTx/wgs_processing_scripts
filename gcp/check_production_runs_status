#!/usr/bin/env bash

source message_functions || exit 1

find_dirs=("/data/cpct/runs/" "/data/cpct/reportable_runs/" "/data/core/runs/" "/data/gcp/processed_runs/")
find_fail_dirs=("/data/gcp/qc_fail_runs")
download_dir="/data/gcp/downloaded_runs"
process_script="process_successful_run"
inspect_healthchecker_failed_run="inspect_healthchecker_log_at_gcp"
download_script="download_run_without_bams"
pipeline="5.22"
run_inis="Somatic.ini|CPCT.ini"

main () {
    echo "## Production Run Status Check for ${run_inis} runs on pipeline version ${pipeline} (date=$(date +'%y%m%d'))"

    # Sanity checks
    check_ini_existance "Somatic.ini"
    check_ini_existance "CPCT.ini"

    # TODO: SVL determine how to solve these check
   # check_pipeline_version_existance "${pipeline}"

    # Create all required run collections
    non_db_entities=( $(query_api.pl -type entities -filter "add_to_db=0" -json | jq -r '.[].name') )
    runs=$(query_api.pl -type runs -filter "ini=${run_inis}" -json)

    all_vali_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Validated")]')
    all_fail_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Failed")]')
    all_fini_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Finished")]')
    all_proc_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Pending" or .status == "Processing")]')
    all_wait_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Waiting")]')

    tumor_samples_with_vali_run=$(get_tumor_samples_from_runs_json "${all_vali_runs}")
    tumor_samples_with_fini_run=$(get_tumor_samples_from_runs_json "${all_fini_runs}")
    tumor_samples_with_proc_run=$(get_tumor_samples_from_runs_json "${all_proc_runs}")
    tumor_samples_with_wait_run=$(get_tumor_samples_from_runs_json "${all_wait_runs}")

    current_vali_runs=$(echo "${all_vali_runs}" | jq --arg pip "${pipeline}" '[.[] | select(.version == $pip)]')
    current_fail_runs=$(echo "${all_fail_runs}" | jq --arg pip "${pipeline}" '[.[] | select(.version == $pip)]')
    current_fini_runs=$(echo "${all_fini_runs}" | jq --arg pip "${pipeline}" '[.[] | select(.version == $pip)]')
    current_proc_runs=$(echo "${all_proc_runs}" | jq --arg pip "${pipeline}" '[.[] | select(.version == $pip)]')
    current_wait_runs=$(echo "${all_wait_runs}" | jq --arg pip "${pipeline}" '[.[] | select(.version == $pip)]')

    # Now ready to check each status on by one
    echo ""
    echo "## Failed runs which are expected to exist on datastore:"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        bucket=$(echo "${run_info}" | cut -f3)

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_finished_run=$(echo "${tumor_samples_with_fini_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        if [[ ${has_valid_run} == 0 && ${has_finished_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 ]]; then
            exists_in_success_run_dirs=$(find "${find_dirs[@]}" -maxdepth 1 -type d -name "${set_name}" | wc -l);
            exists_in_qcfail_run_dirs=$(find "${find_fail_dirs[@]}" -maxdepth 1 -type d -name "${set_name}" | wc -l)

            if [[ ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 ]]; then
                echo "${inspect_healthchecker_failed_run} ${set_name}"
            elif [[ ${exists_in_success_run_dirs} == 0 ]]; then
                echo "# ${set_name} has failed on ${pipeline} and is already on datastore ${find_fail_dirs[*]}"
            else
                echo "# ${sample_name} has Failed on pipeline ${pipeline} but also has a Validated/Processing/Waiting run so can be ignored."
            fi
        fi
    done < <(echo "${current_fail_runs}" | jq -cr '.[] | [.tumor_sample,.name,.bucket] | @tsv')  | sort -r | uniq

    echo ""
    echo "## Finished runs (that are not Validated or Failed, probably waiting for SNP genotype VCF):"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        bucket=$(echo "${run_info}" | cut -f3)

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        if [[ ${has_valid_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 ]]; then
            exists_in_success_run_dirs=$(find "${find_dirs[@]}" -maxdepth 1 -type d -name "${set_name}" | wc -l)
            if [[ ${exists_in_success_run_dirs} == 0 ]]; then
                echo "${download_script} ${set_name} ${download_dir}"
            fi
        else
            echo "# ${sample_name} has Finished on pipeline ${pipeline} but also has a Validated/Processing/Waiting run so can be ignored."
        fi
    done < <(echo "${current_fini_runs}" | jq -cr '.[] | [.tumor_sample,.name,.bucket] | @tsv')  | sort -r | uniq

    echo ""
    echo "## Validated runs that need to be processed:"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        entity=$(echo "${run_info}" | cut -f3)
        exists_in_success_run_dirs=$(find "${find_dirs[@]}" -maxdepth 1 -type d -name "${set_name}" | wc -l);
        if [[ ${exists_in_success_run_dirs} == 0 ]]; then
            if [[ ${set_name} =~ "_HMFregVAL_" ]]; then
                echo "# This is a validation run, so can be ignored for production ${set_name}"
            elif [[ $(printf '%s\n' "${non_db_entities[@]}" | grep -cP "^${entity}$") -gt 0 && ! "${sample_name}" =~ ^CORE.{8}T ]]; then
                ## Skip none-CORE sequencing services runs
                continue
            else
                echo "${process_script} ${set_name}"
            fi
        fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.tumor_sample,.name,.entity] | @tsv')

    echo ""
    echo "## Processing runs:"
    while read -r set_name; do
        echo "# ${set_name} is Processing/Uploading/Downloading"
    done < <(echo "${current_proc_runs}" | jq -cr '.[] | [.name] | @tsv')

    echo ""
    echo "## Waiting runs:"
    while read -r set_name; do
        echo "# ${set_name} is Waiting"
    done < <(echo "${current_wait_runs}" | jq -cr '.[] | [.name] | @tsv')

    echo ""
}

get_tumor_samples_from_runs_json () {
    local runs_json=$1 && shift
    echo "${runs_json}" | jq -r '.[].tumor_sample' | sort | uniq
}

check_ini_existance () {
    local ini=$1 && shift
    ini_count=$(query_api.pl -type inis -filter "name=${ini}" -exact | grep -cv "^#")
    if [[ ${ini_count} != 1 ]]; then
        error "Non-existing ini ${ini})?"
    fi
}

check_pipeline_version_existance () {
    local version=$1 && shift
    pip_count=$(query_api.pl -type stacks -filter "revision=v${version}" | grep -cv "^#")
    if [[ ${pip_count} -lt 1 ]]; then
        error "Non-existing pipeline version (${version})?"
    fi
}

main
