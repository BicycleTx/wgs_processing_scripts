#!/usr/bin/env bash

source message_functions || exit 1

reporting_db_file=/data/ops/lims/prod/reporting_db.tsv
sharing_db_file=/data/ops/lims/prod/final_sharing_db.tsv

failed_reports="dna_analysis_report_insufficient_tcp\|dna_analysis_report_insufficient_tcp_corrected\|insufficient_dna\|insufficient_tcp_deep_wgs\|insufficient_tcp_deep_wgs_corrected\|insufficient_tcp_shallow_wgs\|insufficient_tcp_shallow_wgs_corrected\|qc_fail_report\|sufficient_tcp_qc_failure"

url_bucket_report_pipline="gs://patient-reporter-prod-1/"
url_bucket_report_final="gs://patient-reporter-final-prod-1/"

move_final_report_script="move_report_to_final_reports_gcp"
inspect_healthchecker_script="inspect_healthchecker_log_at_gcp"
major_version="5.22"

main () {
    echo ""
    echo "## Production run status check for runs on pipeline version ${major_version} (date=$(date +'%y%m%d'))"

    # Create all required run collections
    echo "## Retrieving required information from API..."
    mapfile -t non_db_entities < <(hmf_api_get "entities" | jq -r '.[] | select(.add_to_db == false) | .name')
    all_runs=$(hmf_api_get "runs") || die "Unable to retrieve runs from API"
    runs=$(echo "${all_runs}" | jq '[.[] | select(.ini == "Somatic.ini" or .ini == "CPCT.ini")]') || die "Unable to select runs by ini"

    echo "## Creating run collections to check..."
    all_vali_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Validated")]')
    all_fail_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Failed")]')
    all_fini_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Finished")]')
    all_proc_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Pending" or .status == "Processing")]')
    all_wait_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Waiting")]')

    tumor_samples_with_vali_run=$(get_tumor_samples_from_runs_json "${all_vali_runs}")
    tumor_samples_with_fini_run=$(get_tumor_samples_from_runs_json "${all_fini_runs}")
    tumor_samples_with_proc_run=$(get_tumor_samples_from_runs_json "${all_proc_runs}")
    tumor_samples_with_wait_run=$(get_tumor_samples_from_runs_json "${all_wait_runs}")

    # We only consider current runs to check for further processing
    current_vali_runs=$(select_runs_to_check "${all_vali_runs}" "${major_version}")
    current_fail_runs=$(select_runs_to_check "${all_fail_runs}" "${major_version}")
    current_fini_runs=$(select_runs_to_check "${all_fini_runs}" "${major_version}")
    current_proc_runs=$(select_runs_to_check "${all_proc_runs}" "${major_version}")
    current_wait_runs=$(select_runs_to_check "${all_wait_runs}" "")


    # Now ready to check each status on by one
    echo ""
    echo "### Failed runs (that should be sorted out!): ###"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_finished_run=$(echo "${tumor_samples_with_fini_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l );
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${has_valid_run} == 0 && ${has_finished_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 ]]; then
            echo "Please inspect ${set_name} set using: ${inspect_healthchecker_script} ${set_name}"
        fi
    done < <(echo "${current_fail_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')  | sort -r | uniq

    echo ""
    echo "### Failed runs that have already been reported (so no further action needed): ###"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_finished_run=$(echo "${tumor_samples_with_fini_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l );
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[  ${has_valid_run} == 0 && ${has_finished_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ( ${exists_in_success_run_dirs} > 0 || ${exists_in_qcfail_run_dirs} > 0 ) ]]; then
            echo "# ${set_name} has Failed and has already been reported as failed: $( cat ${sharing_db_file} | grep ${sample_name} )"
        else
            echo "# ${set_name} has Failed but has already been reported as succesfull: $( cat ${sharing_db_file} | grep ${sample_name} )"
        fi
    done < <(echo "${current_fail_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')  | sort -r | uniq


    echo ""
    echo "### Finished runs (but not Validated, something with snpcheck?): ###"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)
        research_db_status=$(get_db_status_by_set_name "${set_name}")

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l )
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${has_valid_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 ]]; then
            echo "-- ${set_name} has been finished but not validated. snpcheck issue? # db_status=${db_status}/${research_db_status}"
            perform_snpcheck_run ${set_name}
            echo "---------"
        fi
    done < <(echo "${current_fini_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')  | sort -r | uniq


    echo ""
    echo "### Finished runs that have already been reported (so no further action needed): ###"
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)
        research_db_status=$(get_db_status_by_set_name "${set_name}")

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l )
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${has_valid_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ( ${exists_in_success_run_dirs} > 0 || ${exists_in_qcfail_run_dirs} > 0 ) ]]; then
            echo "# ${set_name} has Finished but has been reported before: $( cat ${sharing_db_file} | grep ${sample_name} )"
            perform_snpcheck_run ${set_name}
            echo "---------"
        fi
    done < <(echo "${current_fini_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')  | sort -r | uniq

    echo ""
    echo "### Validated runs for which the report can be shared: ###"
    counter=0
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        entity=$(echo "${run_info}" | cut -f3)
        db_status=$(echo "${run_info}" | cut -f4)
        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l )
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )
        research_db_status=$(get_db_status_by_set_name "${set_name}")
        if [[ ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 ]]; then
            if [[ ${set_name} =~ "_HMFregVAL_" ]]; then
                counter=$((counter+1))
                echo "# -${counter}- This is a validation run, so can be ignored for production ${set_name}"
            elif [[ $(printf '%s\n' "${non_db_entities[@]}" | grep -cP "^${entity}$") -gt 0 && ! "${sample_name}" =~ ^CORE.{8}T ]]; then
                ## Skip none-CORE sequencing services runs
                continue
            else
                counter=$((counter+1))
                echo "-${counter}- The report for ${sample_name} (run: ${set_name}) can be shared when no errors are found below or in the patient reporter log # db_status=${db_status}/${research_db_status}"
                checks_validated_run ${set_name} ${sample_name}
                if [[ $( gsutil ls ${url_bucket_report_pipline} | grep  ${sample_name} | grep dna_analysis_report.pdf | wc -l ) == 0 ]]; then
                    warn "No report has been created for this set. Please check what went wrong"
                else
                    report_name=$( gsutil ls ${url_bucket_report_pipline} | grep ${sample_name} | grep dna_analysis_report.pdf )
                    report_name=$( echo ${report_name#"gs://patient-reporter-prod-1/"} )
                    info "A report has been created in the bucket ${url_bucket_report_pipline}: ${report_name}"
                fi
                echo " Step 1: Check whether there are no errors above. If no, continue to step 2... "
                echo " Step 2: Download the report to local and check the report. "
                echo " Step 3: Share the report with the relevent persons. "
                echo " Step 4: Move the report to the final archive using the script: ${move_final_report_script} ${sample_name} ${report_name}. "
                echo "---------"
            fi
        fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')

    echo ""
    echo "### Processing/Uploading/Downloading runs: ###"
    while read -r run_info; do
        set_name=$(echo "${run_info}" | cut -f1)
        status=$(echo "${run_info}" | cut -f2)
        echo "# ${set_name} is ${status}"
    done < <(echo "${current_proc_runs}" | jq -cr '.[] | [.set.name,.status] | @tsv')

    echo ""
    echo "### Waiting runs: ###"
    while read -r run_info; do
        set_name=$(echo "${run_info}" | cut -f1)
        status=$(echo "${run_info}" | cut -f2)
        echo "# ${set_name} is ${status}"
    done < <(echo "${current_wait_runs}" | jq -cr '.[] | [.set.name,.status] | @tsv')

    echo ""
}

get_db_status_by_set_name () {
    local set_name=$1 && shift
    hmf_api_get "runs?set_name=${set_name}&bucket=research-pipeline-output-prod-1" | jq -r '.[-1].db_status'
}

select_runs_to_check () {
    local runs_json_input=$1 && shift
    local version_string=$1 && shift
    local bucket_exclude="research-pipeline"
    # Since Pv5.22 the samples-for-db have two runs (diagnostic and research) we want to ignore the research
    echo "${runs_json_input}" | jq \
      --arg vsn "^${version_string}" \
      --arg buk "^${bucket_exclude}" \
      '[.[] | select(.version//"NA"|match($vsn)) | select(.bucket//"NA"|test($buk)|not)]'
}

get_tumor_samples_from_runs_json () {
    local runs_json=$1 && shift
    echo "${runs_json}" | jq -r '.[].tumor_sample' | sort | uniq
}

main
