#!/usr/bin/env bash

source message_functions || exit 1

reporting_db_file=/data/ops/lims/prod/reporting_db.tsv
sharing_db_file=/data/ops/lims/prod/final_sharing_db.tsv

failed_reports="dna_analysis_report_insufficient_tcp\|dna_analysis_report_insufficient_tcp_corrected\|insufficient_dna\|insufficient_tcp_deep_wgs\|insufficient_tcp_deep_wgs_corrected\|insufficient_tcp_shallow_wgs\|insufficient_tcp_shallow_wgs_corrected\|qc_fail_report\|sufficient_tcp_qc_failure"

url_bucket_report_pipline="gs://patient-reporter-prod-1/"
url_bucket_report_final="gs://patient-reporter-final-prod-1/"

move_final_report_script="move_report_to_final_reports_gcp"
inspect_healthchecker_script="inspect_healthchecker_log_at_gcp"
major_version="5.22"


###########

main () {
    echo ""
    echo "## Production run status check for runs on pipeline version ${major_version} (date=$(date +'%y%m%d'))"

    # Create all required run collections
    echo "## Retrieving required information from API..."
    mapfile -t non_db_entities < <(hmf_api_get "entities" | jq -r '.[] | select(.add_to_db == false) | .name')
    all_runs=$(hmf_api_get "runs") || die "Unable to retrieve runs from API"
    runs=$(echo "${all_runs}" | jq '[.[] | select(.ini == "Somatic.ini" or .ini == "CPCT.ini")]') || die "Unable to select runs by ini"

    echo "## Creating run collections to check..."
    all_vali_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Validated")]')
    all_fail_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Failed")]')
    all_fini_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Finished")]')
    all_proc_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Pending" or .status == "Processing")]')
    all_wait_runs=$(echo "${runs}" | jq '[.[] | select(.status == "Waiting")]')

    tumor_samples_with_vali_run=$(get_tumor_samples_from_runs_json "${all_vali_runs}")
    tumor_samples_with_fini_run=$(get_tumor_samples_from_runs_json "${all_fini_runs}")
    tumor_samples_with_proc_run=$(get_tumor_samples_from_runs_json "${all_proc_runs}")
    tumor_samples_with_wait_run=$(get_tumor_samples_from_runs_json "${all_wait_runs}")

    # We only consider current runs to check for further processing
    current_vali_runs=$(select_runs_to_check "${all_vali_runs}" "${major_version}")
    current_fail_runs=$(select_runs_to_check "${all_fail_runs}" "${major_version}")
    current_fini_runs=$(select_runs_to_check "${all_fini_runs}" "${major_version}")
    current_proc_runs=$(select_runs_to_check "${all_proc_runs}" "${major_version}")
    current_wait_runs=$(select_runs_to_check "${all_wait_runs}" "")


    # Now ready to check each status on by one
    echo ""
    echo "### Failed runs (that should be sorted out!):"
    counter=0
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_finished_run=$(echo "${tumor_samples_with_fini_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l );
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${has_valid_run} == 0 && ${has_finished_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 ]]; then
            counter=$((counter+1))
            echo "-${counter}- Please inspect ${set_name} set using: ${inspect_healthchecker_script} ${set_name}"
        fi
    done < <(echo "${current_fail_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')

    echo ""
    echo "### Failed runs that have already been reported (so no further action needed):"
    counter=0
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_finished_run=$(echo "${tumor_samples_with_fini_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l );
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[  ${has_valid_run} == 0 && ${has_finished_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ( ${exists_in_success_run_dirs} > 0 || ${exists_in_qcfail_run_dirs} > 0 ) ]]; then
            counter=$((counter+1))
            echo "# -${counter}- ${set_name} has Failed but has been reported before: $( cat ${sharing_db_file} | grep ${sample_name} )"
        fi
    done < <(echo "${current_fail_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')


    echo ""
    echo "### Finished runs (but not Validated, something with snpcheck?):"
    counter=0
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)
        research_db_status=$(get_db_status_by_set_name "${set_name}")

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l )
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${has_valid_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 ]]; then
            counter=$((counter+1))
            echo "-${counter}- ${set_name} has been finished but not validated. snpcheck issue? # db_status=${db_status}/${research_db_status}"
            perform_snpcheck_run ${set_name}
            echo "---------"
        fi
    done < <(echo "${current_fini_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')

    echo ""
    echo "### Finished runs that have already been reported (so no further action needed):"
    counter=0
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        db_status=$(echo "${run_info}" | cut -f3)
        research_db_status=$(get_db_status_by_set_name "${set_name}")

        has_valid_run=$(echo "${tumor_samples_with_vali_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_processing_run=$(echo "${tumor_samples_with_proc_run}" | tr " " "\n" | grep -cw "${sample_name}")
        has_waiting_run=$(echo "${tumor_samples_with_wait_run}" | tr " " "\n" | grep -cw "${sample_name}")

        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l )
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${has_valid_run} == 0 && ${has_processing_run} == 0 && ${has_waiting_run} == 0 && ( ${exists_in_success_run_dirs} > 0 || ${exists_in_qcfail_run_dirs} > 0 ) ]]; then
            counter=$((counter+1))
            echo "# -${counter}- ${set_name} has Finished but has been reported before: $( cat ${sharing_db_file} | grep ${sample_name} )"
            perform_snpcheck_run ${set_name}
            echo "---------"
        fi
    done < <(echo "${current_fini_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.db_status//"NA"] | @tsv')


    # validated runs pre-processing
    validated_runs_not_yet_reported=""
    while read -r run_info; do
        sample_name=$(echo "${run_info}" | cut -f1)
        set_name=$(echo "${run_info}" | cut -f2)
        entity=$(echo "${run_info}" | cut -f3)
        exists_in_success_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep -v ${failed_reports} | wc -l )
        exists_in_qcfail_run_dirs=$( cat ${sharing_db_file} | grep ${sample_name} | grep ${failed_reports} | wc -l )

        if [[ ${set_name} =~ "_HMFregVAL_" ]]; then
            validation_ss_run=1
        else
            validation_ss_run=1
            if [[ $(printf '%s\n' "${non_db_entities[@]}" | grep -cP "^${entity}$") -gt 0 && ! "${sample_name}" =~ ^CORE.{8}T ]]; then
                ## Skip none-CORE sequencing services runs
                validation_ss_run=0
            fi
        fi

        if [[ ${exists_in_success_run_dirs} == 0 && ${exists_in_qcfail_run_dirs} == 0 && ${validation_ss_run} == 0 ]]; then
            validated_runs_not_yet_reported=$validated_runs_not_yet_reported$set_name" "
            error="none"
            report_error=$( gsutil ls ${url_bucket_report_pipline} | grep  ${sample_name} | grep dna_analysis_report.pdf | wc -l )
            if [[ "$report_error" == *"WARN"* ]]; then
                error="no_report_error"
            else
                health_error=$( checks_validated_run ${set_name} ${sample_name} 2>&1 )
                if [[ "$health_error" == *"WARN"* ]]; then
                    error="other_health_error"
                else
                    if [[ "$health_error" == *"WARN"* && "$error" == *"doid"* ]]; then
                        error="DOID_error"
                    else
                        if [[ "$health_error" == *"WARN"* && "$error" == *"healthchecker"* ]]; then
                            error="healthchecker_error"
                        fi
                    fi
                 fi
            fi
            echo $set_name
            echo $error
            set_name_error="X"$set_name
            error_[$set_name_error]=$error
            echo ${error_[$set_name_error]}
         fi

    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')
    echo $validated_runs_not_yet_reported

    echo ""
    echo "### Validated runs without warnings and with report (that can now be shared):"
    counter=0
    while read -r run_info; do
        if [[ $( echo $validated_runs_not_yet_reported | grep $set_name | wc -l ) > 0 ]]; then
            sample_name=$(echo "${run_info}" | cut -f1)
            set_name=$(echo "${run_info}" | cut -f2)
            set_name_error="X"$set_name
            if [[ "${error_[$set_name_error]}" == "None" ]]; then
                counter=$((counter+1))
                db_status=$(echo "${run_info}" | cut -f4)
                research_db_status=$(get_db_status_by_set_name "${set_name}")
                echo "-${counter}- The report for ${sample_name} (run: ${set_name}) can be shared # db_status=${db_status}/${research_db_status}"
                checks_validated_run ${set_name} ${sample_name} exclude_checks
                report_name=$( gsutil ls ${url_bucket_report_pipline} | grep ${sample_name} | grep dna_analysis_report.pdf )
                report_name=$( echo ${report_name#"gs://patient-reporter-prod-1/"} )
                #info "A report has been created in the bucket ${url_bucket_report_pipline}: ${report_name}"
                echo " Action : Move the report to the final archive using the script: ${move_final_report_script} ${sample_name} ${report_name}. "
                echo "---------"
             fi
         fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')


    echo ""
    echo "### Validated runs without warnings but with no report:"
    counter=0
    while read -r run_info; do
        if [[ $( echo $validated_runs_not_yet_reported | grep $set_name | wc -l ) > 0 ]]; then
            sample_name=$(echo "${run_info}" | cut -f1)
            set_name=$(echo "${run_info}" | cut -f2)
            set_name_error="X"$set_name
            if [[ "${error_[$set_name_error]}" == "no_report_error" ]]; then
                counter=$((counter+1))
                 db_status=$(echo "${run_info}" | cut -f4)
                research_db_status=$(get_db_status_by_set_name "${set_name}")
                echo "-${counter}- There were no warnings for ${set_name}, but no report has been found for ${sample_name} # db_status=${db_status}/${research_db_status}"
                checks_validated_run ${set_name} ${sample_name} exclude_checks
                warn "No report found in the bucket ${url_bucket_report_pipline}"
                echo "---------"
             fi
         fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')

    echo ""
    echo "### Validated runs with healthchecker warning ( please solve! ):"
    counter=0
    while read -r run_info; do
        if [[ $( echo $validated_runs_not_yet_reported | grep $set_name | wc -l ) > 0 ]]; then
            sample_name=$(echo "${run_info}" | cut -f1)
            set_name=$(echo "${run_info}" | cut -f2)
            set_name_error="X"$set_name
            if [[ "${error_[$set_name_error]}" == "healthchecker_error" ]]; then
                counter=$((counter+1))
                db_status=$(echo "${run_info}" | cut -f4)
                research_db_status=$(get_db_status_by_set_name "${set_name}")
                echo "-${counter}- ${set_name} is validated, but the healthchecker failed (see below) # db_status=${db_status}/${research_db_status}"
                checks_validated_run ${set_name} ${sample_name}
                echo "---------"
             fi
         fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')



    echo ""
    echo "### Validated runs with doid warning ( please solve! ):"
    counter=0
    while read -r run_info; do
        if [[ $( echo $validated_runs_not_yet_reported | grep $set_name | wc -l ) > 0 ]]; then
            sample_name=$(echo "${run_info}" | cut -f1)
            set_name=$(echo "${run_info}" | cut -f2)
            set_name_error="X"$set_name
            if [[ "${error_[$set_name_error]}" == "DOID_error" ]]; then
                counter=$((counter+1))
                db_status=$(echo "${run_info}" | cut -f4)
                research_db_status=$(get_db_status_by_set_name "${set_name}")
                echo "-${counter}- ${set_name} is validated, but doid warning see below) # db_status=${db_status}/${research_db_status}"
                checks_validated_run ${set_name} ${sample_name}
                echo "---------"
             fi
         fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')


    echo ""
    echo "### Validated runs with other health warning ( please solve! ):"
    counter=0
    while read -r run_info; do
        if [[ $( echo $validated_runs_not_yet_reported | grep $set_name | wc -l ) > 0 ]]; then
            sample_name=$(echo "${run_info}" | cut -f1)
            set_name=$(echo "${run_info}" | cut -f2)
            set_name_error="X"$set_name
            if [[ "${error_[$set_name_error]}" == "other_health_error" ]]; then
                counter=$((counter+1))
                db_status=$(echo "${run_info}" | cut -f4)
                research_db_status=$(get_db_status_by_set_name "${set_name}")
                echo "-${counter}- ${set_name} is validated, but there is a other warning (see below) # db_status=${db_status}/${research_db_status}"
                checks_validated_run ${set_name} ${sample_name}
                echo "---------"
             fi
         fi
    done < <(echo "${current_vali_runs}" | jq -cr '.[] | [.set.tumor_sample,.set.name,.entity,.db_status//"NA"] | @tsv')

    validated_runs_not_yet_reported=""

    echo ""
    counter=0
    echo "### Processing/Uploading/Downloading runs (no action required):"
    while read -r run_info; do
        counter=$((counter+1))
        set_name=$(echo "${run_info}" | cut -f1)
        status=$(echo "${run_info}" | cut -f2)
        echo "# -${counter}- ${set_name} is ${status}"
    done < <(echo "${current_proc_runs}" | jq -cr '.[] | [.set.name,.status] | @tsv')


    echo ""
    echo "### Waiting runs (no action required):"
    counter=0
    while read -r run_info; do
        counter=$((counter+1))
        set_name=$(echo "${run_info}" | cut -f1)
        status=$(echo "${run_info}" | cut -f2)
        echo "# -${counter}- ${set_name} is ${status}"
    done < <(echo "${current_wait_runs}" | jq -cr '.[] | [.set.name,.status] | @tsv')

    echo ""
}

get_db_status_by_set_name () {
    local set_name=$1 && shift
    hmf_api_get "runs?set_name=${set_name}&bucket=research-pipeline-output-prod-1" | jq -r '.[-1].db_status'
}

select_runs_to_check () {
    local runs_json_input=$1 && shift
    local version_string=$1 && shift
    local bucket_exclude="research-pipeline"
    # Since Pv5.22 the samples-for-db have two runs (diagnostic and research) we want to ignore the research
    echo "${runs_json_input}" | jq \
      --arg vsn "^${version_string}" \
      --arg buk "^${bucket_exclude}" \
      '[.[] | select(.version//"NA"|match($vsn)) | select(.bucket//"NA"|test($buk)|not)]'
}

get_tumor_samples_from_runs_json () {
    local runs_json=$1 && shift
    echo "${runs_json}" | jq -r '.[].tumor_sample' | sort | uniq
}

main
