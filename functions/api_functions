#!/usr/bin/env bash

# There are 4 types of runs:
#  - v5 run. In this case the v5 run holds all the output.
#  - v4 run. In this case, the run info, v3 rerun and v4 rerun are all identical.
#  - v3 run, with a v4 rerun. In this case, the run and v3 rerun are identical, the v4 rerun is separate.
#  - pre-v3 run, with a v3 rerun and a v4 rerun. In this case all 3 run infos will be different.

locate_tumor_cram() {
  local biopsy=$1
  local sample=${biopsy}
  local api_request="datasets/${biopsy}"

  hmf_api_get "${api_request}" | jq -r ".aligned_reads.${sample}.path"
}

locate_reference_cram() {
  local biopsy=$1
  local sample=""
  sample=$(echo "$biopsy" | cut -c1-12)R
  local api_request="datasets/${biopsy}"

  hmf_api_get "${api_request}" | jq -r ".aligned_reads.${sample}.path"
}

load_sample_name_for_barcode() {
  local barcode=$1 && shift
  hmf_api_get "samples?barcode=${barcode}" | jq -r '.[0].name'
}

load_ref_sample_id_for_set() {
    local set=$1
    local name=""
    name=$(load_sample_id_for_set_by_type_from_api "${set}" "ref_sample" )
    echo "${name}"
}

load_tumor_sample_id_for_set() {
    local set=$1 && shift
    local name=""
    name=$(load_sample_id_for_set_by_type_from_api "${set}" "tumor_sample" )
    echo "${name}"
}

load_intial_run_bucket_for_set() {
    local set=$1 && shift

    local run_info=$(load_run_info_for_set ${set})

    # Need to pass as a string because ${run_info} is a string containing spaces.
    extract_bucket_from_run_info "${run_info}"
}

load_sample_id_for_set_by_type_from_api() {
    local set=$1 && shift
    local sample_type=$1 && shift # can be 'ref_sample' or 'tumor_sample'
    local name=""
    name=$(hmf_api_get "sets?name=${set}" | jq -r ".[0].${sample_type}")
    echo "${name}"
}

load_cram_run_bucket_for_set() {
    local set=$1 && shift
    local run_info=""
    local obj_count=""

    run_info=$(hmf_api_get "runs?set_name=${set}&ini=CRAM.ini")
    obj_count=$(echo "${run_info}" | jq 'length')

    # There should be max one CRAM.ini run so return empty if anything else.
    if [[ "$obj_count" -eq 1 ]]; then
        bucket=$(echo "${run_info}" | jq -r '.[0].bucket')
        echo "${bucket}"
    else
        echo ""
    fi
}

load_run_by_set_ini_status(){
    # This function selects the most recent run by setname/ini/status and returns json format
    local set=$1 && shift
    local ini=$1 && shift
    local status=$1 && shift
    local out=""
    out=$(hmf_api_get "runs?set_name=${set}&ini=${ini}&status=${status}" | jq -c '[.[] | select(.bucket|contains("research-pipeline")|not)] | .[-1]')
    if [[ "${out}" == "[]" || "${out}" == "null" ]]; then
        out=""
    fi
    echo "${out}"
}

load_run_info_for_set() {
    # This function aims to select the one "true/final/correct" run for a set and returns json format
    # We do this by moving down the tree of preferred run ini and status and stop once a run is found
    # Most sets will have a Validated Somatic.ini run
    local set=$1 && shift
    local run_info=""

    # Trying all combinations of "final" statuses and inis
    for status in 'Validated' 'Finished' 'Failed' 'Deleted'; do
        for ini in 'Somatic.ini' 'PipelineV5.ini' 'CPCT.ini'; do
            run_info=$(load_run_by_set_ini_status "$set" "$ini" "$status")
            [[ -z "$run_info" ]] || break
        done
        [[ -z "$run_info" ]] || break
    done

    echo "${run_info}"
}

extract_bucket_from_run_info() {
    local run_info=$1 && shift
    jq -r '.bucket' <<< "${run_info}"
}

extract_pipeline_version_from_run_info() {
    local run_info=$1 && shift
    jq -r '.version' <<< "${run_info}"
}

extract_status_from_run_info() {
    local run_info=$1 && shift
    jq -r '.status' <<< "${run_info}"
}